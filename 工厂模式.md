# 工厂模式

### 定义 ：
定义一个用于创建对象的接口（工厂基类中的虚函数），让子类决定实例化哪个类（具体工厂类）
工厂模式使得一个类的实例化延迟到子类（目的：解偶 手段：虚函数）

注：抽象基类或者接口不可以创建对象，不能new, new方法是依赖细节

### 抽象代码：
```

class ISplitter{ 工厂基类
public:
	virtual void split();
	virtual ~ISplitter(){}
};


class SplitterFactory{  
	    抽象工厂方法：具体工厂角色必须实现的接口或者必须继承的父类别
public:
	   virtual Isplitter* CreateSplitter() =0; 抽象类
	   virtual ~SplitterFactory(){}
	   
 };


//具体工厂
class BinarySplitterFactory : public SplitterFactor{
public:
	virtual ISplitter* CreateSplitter(){
		return new BinarySplitter();
	}

};

class MainForm : public Form
{
	SplitterFactory* factory;
	
public:

	MainForm(SplitterFactory* factory){
		this->factory = factory;
	}
	
	void Button1_Click(){
		ISplitter * splitter =
			factory -> CreateSplitter();

		splitter->split();
	}


};


//创建对象的方法
 ISplitter bs();
 
 ISplitter * splitter =
 new BinarySplitter(filePath, number); //依赖具体类
```

摘自： https://blog.csdn.net/silangquan/article/details/20492293

```
class soapBase{ //抽象产品
public:
	virtual ~soapBase(){};
	virtual void show() =0;
};

//对抽象产品的实现
class SFJSoap:public soapBase{ //具体产品
public:
	void show() {cout<<"SFJ Soap!" <<endl;}
};

class 子产品2：public soapBase{

};
   ......

class 子产品n:public soapBase{
};

----------------------------------------

//与应用程序无关，是具体工厂角色必须实现的接口或者必须继承的父类

class FactoryBase{ //抽象工厂
public:
	viurtual soapBase* creatSoap() =0;
}

//对抽象工厂的实现，作用是返回具体的产品
class SFJFactory:public FactoryBase{ //具体工厂
public:
	soapBase* creatSoap(){
		return new SFJSoap(); //创建指向具体产品的实例
	}
};

class Factory2 : public FactoryBase{

};
    ......
class Factoryn : public FctoryBase{

};
 
int main(){

    //创建具体工厂的对象
	SFJFactory factory1;
	//用抽象产品类指针指向
	soapBase* pSoap1 = factory1.createSoap();
	//用指针调用具体产品方法
	pSoap1->show();


	//也就是说，基类指针是一样的，但是对象不一样，调用的对象中的方法就不一样

	XSLFactory factory2;
    soapBase* pSoap2 = factory2.creatSoap();
	pSoap2->show();

	delete pSoap1;
	delete pSoap2;
	return 0;
}

```

### 思考
    设计模进行修改不是消灭了变化，而是把变化放在MainForm外面

### 优点缺点
	1 工厂模式用于隔离类对象的使用者和具体类型之间的耦合关系。面对一个经常变化的具体类型
	  紧偶和关系（new）会导致软件的脆弱
	2 工厂模式通过面向对象的手法，将所要创建的具体对象工作延迟到子类，从而实现一种扩展而
	非更改的策略，较好的解决了这种紧耦合关系
	3 工厂模式解决“单个对象”的需求变化，缺点在于要求创建方法/参数相同，即每增加一种产品，
	就要增加一个对像的工厂

