###
#### 右值引用及move语义
右值： 赋值运算符右侧的临时对象， 等同于 const T&
右值引用：  T &&
右值引用所绑定的临时对象可以在该临时对象被初始化之后做修改，这是为了允许move语义
```
```
把一个vector的右值引用作为参数std::vector的move构造函数，可以把右值参数所绑定的vector内部的指向数组的指针复制给新的vector，
然后把该指针置为null，

右值引用作为数据类型的引入，使得函数可以重载区分它的参数是值类型、传统的左值引用还是右值引用。
这让除了标准库的现有代码无须任何改动就能等到性能提升。一个回返std::vector<T>的函数的回返类型无须为了调用move构造函数而显式修改为std::vector<T>&&，因为临时对象自动作为右值。

#### constexpr  泛化的常量表达式
C++ 中常量表达式不能含有函数调用或是对象构造函数
但是，constexpr 允许用户保证函数或是对象构造函数式编译器常量

+ 用constexpr修饰函数将限制函数的行为。
+ 首先，该函数的回返值类型不能为void。
+ 第二，函数的内容必须依照"return expr"的形式。
+ 第三，在参数替换后，expr必须是个常量表示式。
+ 这些常量表示式只能够调用其他被定义为constexpr的函数，或是其他常量表示式的数据参数。
+ 最后，有着这样修饰符的函数直到在该编译单元内被定义之前是不能够被调用的。 

```
constexpr int GetFive() {return 5;}
int some_value[GetFive() + 7]； //是正确的
```
C++11之前，可以在常量表达式中使用的的变量必须被声明为const，用常量表达式来初始化，并且必须是整型或枚举类型。
C++11去除了变量必须是整型或枚举类型的限制，只要变量使用了constexpr关键字来定义： 

#### 类型推导  auto   decltype 
#### 基于范围的for循环
```
for(auto &x : my_array){
    x*= 2;
}
```
#### Lambda 函数与表达式   临时函数

#### 委托构造函数
允许构造函数调用其他构造函数

#### 显式虚函数重载

#### final

#### 空指针常量   nullptr 将空指针和证书0分开  nullptr 的类型未nullptr_t 能隐式转换为任何指针或是成员指针的类型，也可以和他们进行相等或不等的比较
nullptr 不能隐式转换为整数，不能和整数比较

```
char* pc = nullptr;     // OK
int * pi = nullptr;     // OK
int    i = nullptr;     // error
bool   b = nullptr;     // OK

foo(pc);           // 调用foo(char *), 而不是 foo(int);
foo(nullptr);      // 调用foo(nullptr_t);

```

