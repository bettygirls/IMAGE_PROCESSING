From: https://blog.csdn.net/u011857683/article/details/52336805
+ 多线程的环境中，需要保持线程同步时，通过锁来实现
```
互斥锁的使用过程，主要有：

第一：线程锁的初始化，pthread_mutex_init
第二：线程锁的释放，pthread_mutex_destory
第三：线程锁的加锁操作，pthread_mutex_lock
第四：线程锁的解锁操作，pthread_mutex_unlock

******锁的初始化******
可以采用静态或者动态的方法建锁

1 静态建锁， 无需释放操作：
可以用宏PTHREAD_MUTEX_INITIALIZER来静态的初始化锁，互斥锁是pthread_mutex_t的结构体，
而这个宏是一个结构常量，如下可以完成静态的初始化锁：
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZAER；

2 动态创建，需要释放操作
(1)初始化操作 pthread_mutex_init 原函数类型如下：
int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t * attr)
创建：
pthread_mutex_t m_Mutex = PTHREAD_MUTEX_INITIALIZER;

(2) 释放函数pthread_mutex_destroy 可以释放锁占用的资源，但这有一个前提：锁当前是没有被锁的状态。
原函数类型：
int pthread_mutex_destroy(pthread_mutex_t *mutex)
**** mutex 指向要销毁的互斥锁的指针,互斥锁销毁函数在执行成功后返回 0，否则返回错误码。

具体操作为：
pthread_mutex_init(&mutex, NULL);
pthread_mutex_destroy(&mutex);

3 加锁与解锁
pthred_mutex_trylock() 为尝试锁，如果已经加锁则直接返回EBUSY
pthread_mutex_lock() 是挂起等待；

int pthread_mutex_lock(pthread_mutex_t *mutex);
int pthread_mutex_unlock(pthread_mutex_t *mutex);
int pthread_mutex_trylock(pthread_mutex_t *mutex);

4 线程锁的简单封装
思路：
互斥器放在类外，外部初始化互斥器，然后传进互斥器（方法1，2）
互斥器放在类内，内部直接初始化互斥器，然后使用互斥器（方法3）

```
+ 方法1 静态初始化，同时进行资源管理，保证自动释放锁（这种方式最好，如果动态初始化，页一样）
```
// Lock.h
#ifndef Lock_ H_
#define Lock_H_
#include<pthread.h>  //头文件
class Lock
{
 
public:
    Lock(pthread_mutex_t* m_Mutex);  //构造函数
    ~Lock();  //析构函数
 
    void mutexLock();  //加锁
    void mutexUnlock(); //解锁
 
private:
    pthread_mutex_t* m_Mutex; // 私有数据成员 是一个指针
};
#endif

------------------------------------------------------------------
//Lock.cpp

#include "Lock.h"
#include <stdio.h>
#include <errno.h>
 
 
Lock::Lock(pthread_mutex_t* m_Mutex):m_Mutex(m_Mutex) //构造函数，初始化了数据成员，并且执行了加锁操作
{
    mutexLock();
}
 
Lock::~Lock()  //析构函数，调用了解锁操作
{
    mutexUnlock();
}
 
 
void Lock::mutexLock()  
{
    //非空,则进行加锁操作,关于指针,每次操作前最好确定进行非空判断,保证程序不会中断
    if(this->m_Mutex)          
    {
        pthread_mutex_lock(this->m_Mutex);  
    }  
}
 
 
void Lock::mutexUnlock()
{
    //非空,则进行解锁锁操作,关于指针,每次操作前最好确定进行非空判断,保证程序不会中断
    if(this->m_Mutex)
    {
        pthread_mutex_unlock(this->m_Mutex);
    } 
}
------------------------------------------------------------------
#include <stdio.h>
#include <memory>
#include <string>
#include "Lock.h"
 
pthread_mutex_t m_Mutex = PTHREAD_MUTEX_INITIALIZER;                   //静态初始化，类外初始化
 
 
void *testMsg(void *testMsg)
{
    char *msg = (char *)testMsg;
    
   //类对象的定义
    Lock test_lock(&m_Mutex);   //创建锁对象时，需要把互斥器传进去，进行资源管理，无需手动解锁，过了作用域自动解锁
    
    for(int i=0; i< 5; i++ )
    {
        printf("testMsg(%d): %s\n", i+1, msg);
        sleep(1); // 睡眠
    }
 
 
    return NULL;
}
 
 
int main()
{
    pthread_t test1,test2;
    //pthread_t 声明线程ID
    //sizeof(pthread_t) = 8
 
 
    //创建两个工作线程
    pthread_create( &test1, NULL, &testMsg, (void *)"First thread");       
    pthread_create( &test2, NULL, &testMsg, (void *)"Second thread");        
 
 
    //等待线程结束                                             
    pthread_join( test1, NULL);                               
    pthread_join( test2, NULL);                               
 
 
    return 0;                                             
}


```
+ 相关函数
```
pthread_create 是线程创建函数，功能是创建线程（实际上就是确定调用该线程函数的入口点），在线程创建后运行
相关的线程函数
pthread_create 的返回值表示成功，返回0， 表示出错，返回1

头文件  #include<pthread.h>
编译链接参数 -lpthread

int pthread_create(pthread_t *tidp,const pthread_attr_t *attr,(void*)(*start_rtn)(void*),void *arg);

返回值：
若线程创建成功，则返回0。若线程创建失败，则返回出错编号，并且*thread中的内容是未定义的。

返回成功时，由tidp指向的内存单元被设置为新创建线程的线程ID。
attr参数用于指定各种不同的线程属性。
新创建的线程从start_rtn函数的地址开始运行，该函数只有一个万能指针参数arg，
如果需要向start_rtn函数传递的参数不止一个，那么需要把这些参数放到一个结构中，然后把这个结构的地址作为arg的参数传入。

参数：
第一个参数为指向线程标识符的指针
第二个参数是用来设置线程属性
第三个参数是线程运行函数的起始地址
最后一个参数是运行函数的参数

2 pthread_attr_t类型的参数

typedef struct
{
    int detachstate;//线程的分离状态
    int schedpolicy;//线程的调度策略
    struct sched_param schedparam;//线程的调度参数
    int inneritsched;//线程的继承性
    int scope;//线程的作用域
    size_t guardsize;//线程栈末尾的警戒缓冲区大小
    int stackaddr_set;//线程堆栈的地址集
    void *stackaddr;//线程栈的位置
    size_t stacksize;//线程栈的大小
}pthread_attr_t;

1 分离状态：
(1)线程的分离转台聚顶一个线程以什么样的方式来终结自己。
(2)在默认情况下，线程是非分离状态的，这种情况下，原有的线程等待创建的线程结束，只有当pthread_join()函数返回时，
创建的线程才算终止，才能释放自己所占的资源
(3)分离线程没有被其他线程等待，自己运行结束了，线程也就终止了，马上释放系统资源
参数: 
1.attr 线程属性变量 
2.detachstate 分离状态属性
分离状态的两种属性: 
PTHREAD_CREATE_DETACHED 以分离状态启动线程 
PTHREAD_CREATE_JOINABLE 正常启动线程

2 线程的调度策略
所谓的调度策略也就是操作系统中的那些调度算法
1.SCHED_FIFO:先进先出 
2.SCHED_RR:轮转法 
3.SCHED_OTHER:其他方法 
前两种策略支持优先级并且只对超级用户有效, 最后一种方法不支持优先级.
注意
此处的SCHED_FIFO是允许被高优先级抢占的, 即, 高优先级的必须先运行.
SCHED_RR是设置一个时间片.
当有SCHED_FIFO或SCHED_RR策略的线程在同一条件变量上等待或者等待加锁同一个互斥量时, 它们将以优先级顺序被唤醒, 即优先级高的总是首先被解除阻塞.


3.调度参数
一个struct sched_param结构, 里面有一个sched_priority的参数, 其本质就是线程运行的优先级.
sched_priority的默认值为0;

4.继承性
继承性决定调度的参数时从创建的线程中继承还是使用在schedpolicy和schedparam属性中显示设置的调度信息.
默认值为schedpolicy和schedparam属性中显式设置的值.
可设置的参数: 
PTHREAD_EXPLICIT_SCHED 继承创建线程的策略和参数 
PTHREAD_INHERIT_SCHED 继承属性中显式设置值

5.线程的作用域
线程的作用域表示了线程间竞争CPU的范围, 也就是说, 线程优先级的有效范围. 
POSIX标准中定义了两个值为: 
PTHREAD_SCOPE_PROCESS 进程级竞争资源
PTHREAD_SCOPE_SYSTEM 系统级竞争资源

```
