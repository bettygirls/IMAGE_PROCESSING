# 二叉树

  二叉树度为0的结点数为度为2的结点加1
  n0 = n2 + 1

  完全二叉树总结点n 叶子节点有几个：
  n0 = n2 + 1
  n = n0 + n1 + n2
  
  完全二叉树度为1的只有一个或0个

  所以 n0 = (n + 1) /2
       或者 n0 = n / 2  选择计算出来是整数的
## 二叉树结构
	   struct node{

		   int val
		   node* left;
		   node* right;
		   node(int x):val(x),left(NULL),right(NULL){}

	   };

## 二叉树创建
```C++
   \\创建节点
   TreeNode a(1);
   TreeNode b(2);
   TreeNode c(3);
   \\链接结点
   a->left = &b;
   a->right = &c;

```

## 二叉树遍历

### 前序遍历
    第一次遇到一个节点就打印出来

#### 递归
```
void printBT_pre_recur(TreeNode* pRoot){

	//递归退出条件
	if(pRoot == NULL )
		return ;
	cout<< pRoot->val<<endl;
	printBT(pRoot->left);
	printBT(pRoot->right);
}
```
#### 非递归
     利用栈结构实现
	 先将根节点压栈
	 弹出并打印
	**** 按照先右孩子后左孩子的方法压栈
```
void pre_order(TreeNode* pRoot){
	if(pRoot != NULL){
		stack<TreeNode*> S;
		S.push(pRoot);
		while(!S.empty()){
			pRoot = S.top();
			S.pop();
			cout<<pRoot->value<<" ";
			if(pRoot->right != NULL){
				S.push(pRoot->right);
			}
			if(pRoot->left != NULL){
				S.push(pRoot->left);
			}
		}
	}
	return 0;
}

```

### 中序遍历

#### 递归
#### 非递归


### 后序遍历
#### 递归
#### 非递归

### 层序遍历

## 重建二叉树

   利用前序和中序数组重建二叉树

```
//输出： 重建后的二叉树 TreeNode* 类型
//输入： 中序和前序数组

class Solution {  
public:    
        TreeNode* reConstructBinaryTree(vector<int> pre, vector<int> in){
        //中序遍历第一个元素是根节点
						        
	        int len = in.size();
	        if(len == 0)
	            return NULL;
	        int d ;
	        //在中序数组中找到跟节点,取得下标d
	        for(int i = 0; i < len; i++){
	            if(in[i] == pre[0]){
	               d = i;
	               break;
	            }
	        }
	        //返回的根结点 ××××××××
	        TreeNode* head = new TreeNode(pre[0]);

	        //将左子树保存在一个数组中，右子树保存在一个数组中
	        vector<int> pre_left, pre_right, in_left, in_right;

	        for(int i = 0 ; i < d; i++){  //标记为d
	            pre_left.push_back(pre[i+1]); //此处前序遍历坐标+1
	            in_left.push_back(in[i]);
	        }
	        for(int j = d+1; j < len; j++){
	            pre_right.push_back(pre[j]); //此处都为j
	            in_right.push_back(in[j]);
	        }
        //递归调用
		head->left = reConstructBinaryTree(pre_left,in_left);
        head->right = reConstructBinaryTree(pre_right,in_right);
        return head;
	}
					  
};
	

```

## 树的子结构

   判断一棵树b是否是另一棵树a的子结构
   空树不是任意一棵树的子结构

```
//输入 ： 两棵树 TreeNode* 类型
//输出  : bool 类型是否

bool  HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2){

	if(pRoot1 == NULL || pRoot2 == NULL)
		return false;
	//然后递归的判断当前节点下的树，左孩子下的树，右孩子下的树

	return check(pRoot1,pRoot2) || HasSubtree(pRoot1->left,pRoot2) ||HasSubtree(pRoot1->right,pRoot2);
                                      //check 当前节点  这里是递归处理左右子树
}

bool check(TreeNode* p , TreeNode* pRoot2){
	//p 为空 pRoot2 不为空

	//p 不为空 pRoot2为空 未到跟节点 
	//p 为空 pRoot2 为空  跟节点 

	if(pRoot2 == NULL) 
		return true;

	if(p == NULL ) //对应pRoot2 不为空
		return false;

	//两者都不为空
	if(p != NULL && pRoot2 != NULL && p->val == pRoot2->val)
		return check(p->left, pRoot2->left) && check(p->right, pRoot2->right);
	return false;
}
```

## 二叉树镜像

   给定一棵二叉树，将其变为源二叉树的镜像

```
//输入： 二叉树
//输出 ：void  如果需要显式输出的话，用打印的方法打印出来

void  mirror(TreeNode* pRoot){
	if(pRoot == NULL)
		return ;
	
		TreeNode* tmp;
		tmp = pRoot->left;
		pRoot->left = pRoot->right;
		pRoot->right = tmp;

		//左右孩子交换之后，左右孩子的子结点跟着变换
		mirror(p->left);
		mirror(p->right);
	
}
```
## 二叉树层序遍历

```
输入： 一棵二叉树
输出： vector序列

vector<int> PrintFromTopToBottom(TreeNode* pRoot){
      //这句不需要写，后面出现空会进行判断	if(pRoot == NULL) return 0; 而且应该返回一个vector类型
	queue<TreeNode*> Q;
	Q.push(pRoot);
	vector<int> res;
    TreeNode*  tmp;
	while(!Q.empty()){

		tmp = Q.front();
		Q.pop();
        
		//不打印空结点
		if(!tmp){
			continue;
		}

		//元素弹出的时候要立刻打印
		res.push_back(tmp->val);


		if(tmp->left) Q.push(tmp->left);
		if(tmp->right) Q.push(tmp->right);

	}
	return res;
}
```

## 判断数列是否是搜索二叉树后序遍历


