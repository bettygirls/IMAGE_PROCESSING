

##### 内存分为：堆，栈，自由存储区，全局/静态存储区和常量存储区

## 栈
在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。
栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。

## 堆
就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。
如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。

## 自由存储区
就是那些由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自己的生命的。

## 全局静态存储区
全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。

## 常量存储区
这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。

## 堆和栈的区别
```

                        栈                      堆
1、管理方式不同；     编译器自动管理，    手动管理产生内存泄漏
2、空间大小不同；      1M                           4G
3、能否产生碎片不同；   内存是连续的             内存不连续
4、生长方向不同；     栈是向下的                 堆是向上的
5、分配方式不同；  静态和动态（alloc）都可以          动态
6、分配效率不同；    机器系统提供的数据结构            库函数提供十分复杂
```

## 内存管理的优化策略
　  【规则1】用malloc或new申请内存之后，应该立即检查指针值是否为NULL。防止使用指针值为NULL的内存。
　　【规则2】不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。
　　【规则3】避免数组或指针的下标越界，特别要当心发生“多1”或者“少1”操作。
　　【规则4】动态内存的申请与释放必须配对，防止内存泄漏。
　　【规则5】用free或delete释放了内存之后，立即将指针设置为NULL，防止产生“野指针”


## STL 的 allocate
申请操作：
1.	如果用户需要的区块大于128，则直接调用第一级空间配置器（直接调用malloc和free来配置释放内存，简单明了）
2.	如果用户需要的区块小于128，则到自由链表中去找 

1.	如果自由链表有，则直接去取走
2.	不然则需要装填自由链表（Refill）


释放操作：
     1 如果区块大于128，则直接由第一级空间配置器收回
     2 如果区块小于等于128，则由自由链表收回
     
## deque 的内存分配
deque 分配内存的开销低于vector,因为deque有中心枢纽元，用4个指针维护当前的队列，中心枢纽元的每个指针是
指向另一个连续内存的

## 内存泄漏及检查
调用了malloc/new等内存申请的操作，但是缺少了对应的free/delete
程序员需要保证两个调用的次数是一样的
检测内存泄漏的关键就是，检查是否匹配，要做到这一点就是利用宏或者钩子
在用户程序和运行库之间加了一层用于记录内存分配的情况
工具有： valgrind

## linux 内存管理机制
ps aux 观测指定进程的状态
可以通过top和free -h 查看内存的使用情况
linux把物理内存划分一部分空间出来，称作cache/buffers，以此来提高数据的访问性能，页面的缓存(cache)是
linux内核实现的一种主要磁盘缓存，主要用来减少对磁盘I/0的操作
free -h
纵向的：
total 表示内存总大小
used 表示已使用的物理内存大小
free 表示空闲的内存大小
shared 表示多个进程共享的内存大小
buffers/cached 表示磁盘缓存的大小
横向的：
men 表示物理内存
swap 交换分区的使用情况， 通常swap的大小是物理内存大小 * 2倍

free -l 可以显示最高和最低的内存使用情况


## C++优化内存分配
```
使用new操作符时，分为2步： 1 给对象分配内存，这时内存是未构造的 2 在分配内存处运行构造函数
delete 也有2步： 1 调用析构函数  2 把对象所用内存还给系统

在处理C++内存分配时，要解决2个问题:
1.分配原始内存，必须在内存中构造对象
2.在释放内存之前，必须适当地撤销对象


C++ 提供2种方法来分配和释放未构造的原始内存：
1 allocator类
2 operator new 和 operator delete

C++也提供了不同的方法在原始内存种构造和撤销对象：

1 allocator类的成员函数construct在未构造的内存中初始化对象，成员函数destroy在对象运行析构函数
   allocator 类是一个模板类，可以提供类型化内存分配和对象的构造和撤销
   
2 定位new表达式，它接受之前未构造的内存的指针，在该内存中初始化对象和数组，并不分配内存

3 直接调用对象的构造，析构函数，运行析构函数并不是释放对象所占用内存，只是销毁对象
4 算法 uninitilaized_fill 和 uninitialized_copy

```
                                

