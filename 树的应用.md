
#### 二叉搜索数（BST）二叉排序树（Binary Sort Tree），又称二叉查找树（Binary Search Tree)
```
1 左子树上的所有结点值均小于或等于根节点上的值
2 右子树上的所有结点值均大于等于根节点的值
3 左右子树也分别为二叉排序树


优点：
查找的时候是二分查找的思想，所需的最大查找次数是二叉树的高度
缺点：
不平衡的时候会退化成链表


```
#### 平衡树

#### 自平衡二叉查找树
```

```


#### 红黑树
```
enum Color
{
          RED = 0,
          BLACK = 1
};

struct RBTreeNode
{
           struct RBTreeNode*left, *right, *parent;
           int   key;
           int data;
           Color color;
};

红黑树是一种自平衡的二叉查找树  时间复杂度为O（lgn）

性质：
1 节点是红色或者黑色
2 根节点是黑色
3 每个叶子接待你都是黑色的空节点（NIL节点）
4 每个红色节点的两个子节点都是黑色（从每个叶子到根的所有路径上不能有两个连续的红色节点）
5 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点

从根到叶子的最长路径不会超过最短路径的2倍

调整方法： 变色和旋转（左旋和右旋）
变色方法：
红变黑或者黑变红

左旋转：
 逆时针旋转两个节点，父节点被自己的右孩子取代，父节点成为自己的左孩子， 其他节点的相对位置不发生变化
 \                           \
  x                           y
 /  \                        /  \
a    y                      x    c
    /  \                   /  \
    b   c                 a    b
    
 右旋转：
 逆时针旋转两个节点，父节点被自己的左孩子取代，父节点成为自己的右孩子， 其他节点的相对位置不发生变化
   \                           \
    x                           y
   /  \                        /  \
  y    a                     b    x
/  \                       /  \
b   c                     c    a

应用：
STL 的set的底层实现

```
####  B树   多路平衡查找树
每个节点最多包含k个孩子，k被称为B树的阶，k的大小取决于磁盘页的大小

```
Mysql 数据库的索引是基于什么数据结构
Hash 表或者B+ 树（关系型数据库B+树做索引）
B树（比如著名的非关系型数据库 MongoDB）

数据库的索引是存储在磁盘上的，当数据量比较大的时候，索引的大小可能好几个G，无法全部加载到内存
所以要IO读取，但是IO读取很慢
为了减少IO读取的次数，需要把二叉树变的矮胖

m阶B树的性质：
1 根节点至少有两个子女
2 每个中间节点都包含 k-1个元素和k个孩子，其中 m/2 <= k <= m
3 每个叶子节点都包含k-1个元素，其中 m/2 <= k <= m

4 所有的叶子结点都位于同一层
5 每个结点中的元素从小到大排列，节点中k-1个元素正好是k个孩子包含的元素的值域划分
                     9
                  /      \
               2  6        12
              /  |  \     /    \
            1   3 5  8    11   13 15
  当单一节点中的元素很多的时候，查找次数也很多，但是相比IO的读取速度可以忽略
  


```

#### B+ 树
```
m阶B+ 树的性质：
1  有k个子树的中间节点包含有k个元素（B树中是K-1个），每个元素不保存数据，只用来索引，所有数据都
保存在叶子节点
2 所有的叶子节点中包含了全部元素的信息，以及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接
3 所有的中间结点元素都同时存在于子结点，在子节点元素中式最大（或最小）元素

父节点出现在子节点中，是子节点的最大或最小元素
根节点的最大元素等同于整个B+树的最大元素
卫星数据，索引元素所指向的数据记录，B树中，所有结点都有卫星数据，B+树中只有叶子结点有卫星数据，中间结点只有索引
叶子结点之间从左向右用指针链接

在数据库的聚集索引（Clustered Index）中，叶子节点直接包含卫星数据。
在非聚集索引（NonClustered Index）中，叶子节点带有指向卫星数据的指针。

优势：
体现在查询性能上，单元素查询和范围查询
1   由于B+树中间没有卫星数据，所以同样大小的磁盘页可以容纳更多的节点元素，这就意味着在数据量相同的情况下，B+树的结构，比B-树
更加矮胖IO查询次数也少
2  B树的查找性能并不稳定，最好情况是根节点，最坏是叶子节点，B+稳定
3 B 树的范围查询依靠中序遍历， B+树的范围只需要在链表上做遍历
所以  B+ 比 B 树的优势：
    1 IO次数更少
    2 查询性能稳定
    3 范围查询简便
    
    
B+树的特征：

1.有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。

2.所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。

3.所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。


B+树的优势：

1.单一节点存储更多的元素，使得查询的IO次数更少。

2.所有查询都要查找到叶子节点，查询性能稳定。

3.所有叶子节点形成有序链表，便于范围查询。


```

#### 红黑树相对于哈希表
```

权衡三个因素: 查找速度, 数据量, 内存使用，可扩展性。
　　总体来说，hash查找速度会比map快，而且查找速度基本和数据量大小无关，属于常数级别;而map的查找速度是log(n)级别。并不一定常数就比log(n) 小，hash还有hash函数的耗时，明白了吧，如果你考虑效率，特别是在元素达到一定数量级时，考虑考虑hash。但若你对内存使用特别严格， 希望程序尽可能少消耗内存，那么一定要小心，hash可能会让你陷入尴尬，特别是当你的hash对象特别多时，你就更无法控制了，而且 hash的构造速度较慢。
红黑树并不适应所有应用树的领域。如果数据基本上是静态的，那么让他们待在他们能够插入，并且不影响平衡的地方会具有更好的性能。如果数据完全是静态的，例如，做一个哈希表，性能可能会更好一些。

在实际的系统中，例如，需要使用动态规则的防火墙系统，使用红黑树而不是散列表被实践证明具有更好的伸缩性。Linux内核在管理vm_area_struct时就是采用了红黑树来维护内存块的。
红黑树通过扩展节点域可以在不改变时间复杂度的情况下得到结点的秩。

```
