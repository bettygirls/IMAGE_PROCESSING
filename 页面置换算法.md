#### 页面置换算法
地址映射过程中，若页面中发现所要访问的页面不在内存中，会产生缺页中断，当缺页中断发生时，操作系统需要在内存中选择一个
页面将其移出内存

+ （1） 最佳置换算法 （OPT）
理想情况下的页面置换算法，实际上是不可能实现的。
当发生缺页时，将标记被调用指令最大的页被置换，因为无法估计每个页被调换的时间，所以这个算法可以用于对实现算法的
性能进行比较

+ （2） 先进先出置换算法（FIFO）
最先进入内存的页，先退出内存

建立一个FIFO队列，收容所有在内存中的页，被置换页面总是在队列头上进行，当一个页面被放入内存时，就把它插在队尾上
这种算法只是在按线性顺序访问地址空间时才是理想的，否则效率不高，因为那些常被访问的页，往往在主存中也是停留的最久
结果他们因变老而不得不被置换出去
FIFO的另一个缺点是，它有一种异常现象，在增加存储块的情况下，反而使缺页中断率增加了，称为Belady现象

+ （3） 最久未使用算法（LRU）
FIFO算法和OPT算法之间的主要区别是，FIFO算法利用页面进入内存后的时间长短作为置换依据，OPT
算法的依据是将来使用页面的时间。
如果以最近的过去作为不久将来的近似，那么就可以把过去最长一段时间里不曾被使用的页面置换掉。它的实质是需要置换一页的时候
选择在最近一段时间最久没有使用过的页面予以置换

如何确定最后使用时间的顺序：

1 计数器。 最简单的情况是使每个页表项对应一个使用时间段，并给CPU增加一个逻辑时钟或者计数器
每次存储访问，该时钟都加1.每当访问一个页面时，时钟寄存器的内容就被复制到相应页表项的使用时间字段中
这样我们就可以时钟保留着每个页面最后访问的时间，在置换页面时，选择该时间值最小的页面。这样做不仅要查页表，
而且当页表改变时（因CPU调度）要维护这个页表中的时间，还要考虑到时钟值溢出的问题。

2栈 用一个栈保留页号。每当访问一个页面时，就把它从栈中取出来放在栈顶上。这样一来，栈顶总是放有目前使用最多的
页，栈底放着目前使用最少的页，由于要从栈的中间移走一项，所以要用具有头尾指针的双向链表连起来。在最坏的情况下，
移走一页并把它放在栈顶需要改动6个指针。每次修改都要有开销，但需要置换哪个页面却可直接得到，用不着查找，因为尾指针
指向栈底，其中有被置换页

近似LRU算法，它在存储分块表的每一表项中增加一个引用位，操作系统定期地将它们置位0，当某一页被访问时，有硬件将该位置1，过一段
时间后，通过检查这些为可以确定哪些页使用过，哪些页自上次置0后还未使用过。就可把该位淘汰出去，因为在最近一段时间里它未被访问过

+ （4）Clock置换算法（LRU算法的近似实现）

+ （5） 最少使用（LFU）置换算法
在采用该方法时，应该在内存中的每个页面设置一个移位寄存器，用来记录该页面被访问的频率。该置换算法选择在最近时期使用最少的页面作为淘汰
页。由于存储器具有较高的访问速度，通常不能直接利用计数器来记录某页被访问的次数，而是采用移位寄存器，每次访问某页时，便将该移位寄存器的最高
位置1，再每隔一定时间右移一次，这样，在最近一段时间使用最少的页面就是sum(Ri)最小的页

LFU 算法和的页面访问图和LRU置换算法的访问图完全相同，但是LFU算法并不能真正反映出页面的使用情况，因为在每一时间间隔内，
只用寄存器的一位来记录页的使用情况，访问1次和10000次是等效的
