
##### 单例模式
构造函数声明为private或protect防止被外部函数实例化，内部保存一个privete static 的类指针保存唯一的实例，实例的动作由一个public的类方法代劳

```
class singleton{
protected:
    singleton(){}
private:
    static singleton* p;
public:
    static singleton* instance();
};

singleton* singleton::p = NULL;
singletion* singleton::instance()
{
    if(p == NULL)
        p = new singleton();
    return p;
}

注释： 线程不安全， 两个线程同时首次调用instance同时检查到p是NULL值，则两个线程会同时构造一个实例给p
```
##### 场景选择

由于要进行线程同步，所以在访问量比较大，或者可能访问的线程比较多时，采用饿汉实现，可以实现更好的性能。这是以空间换时间。
在访问量较小时，采用懒汉实现。这是以时间换空间。

#### 懒汉模式
只有在用到类实例的时候才会实例化
```
//加锁的线程安全
class singleton{
protected:
    singleton(){
        pthread_mutex_init(&mutex);   //在构造函数里面初始化锁
    }
private:
    static singleton* p;
public:
    static pthread_mutex_t mutex;     //对外有指针
    static singleton* instance();
};
pthread_mutex_t singleton::mutex;
singleton* singleton :: p = NULL;
singleton* singleton::instance()
{
    if(p == NULL){    // 两次判空是为什么
        pthread_mutex_lock(&mutex); //使用前加锁
        if(p == NULL)
           p = new singleton();
           pthread_mutex_unlock(&mutex);  //使用后解锁
    }
    return p;
}

所谓双重检查加锁机制，指的是：
并不是每次进入getInstance方法都需要同步，而是先不同步，进入方法过后，先检查实例是否存在，如果不存在才进入下面的同步块，这是第一重检查。
进入同步块过后，再次检查实例是否存在，如果不存在，就在同步的情况下创建一个实例，这是第二重检查。
这样一来，就只需要同步一次了，从而减少了多次在同步情况下进行判断所浪费的时间。

双重检查加锁机制的实现会使用一个关键字volatile，它的意思是：被volatile修饰的变量的值，将不会被本地线程缓存，所有对该变量的读写都是直接操作共享内存,从而确保多个线程能正确的处理该变量。

```
```
// 内部静态变量实现
在instance里面定义静态实例，也可以保证拥有唯一实例，返回指针就可以

class singleton{
protected:
    singleton(){
        pthread_mutex_init(&mutex);   //在构造函数里面初始化锁
    }
public:
    static pthread_mutex_t mutex;     //对外有指针
    static singleton* instance();
    int a;
};
pthread_mutex_t singleton::mutex;
singleton* singleton::instance()
{
    
        pthread_mutex_lock(&mutex); //使用前加锁
        static singleton obj;  //静态对象
        pthread_mutex_unlock(&mutex);  //使用后解锁
        return &obj;
}

```


#### 饿汉模式

在单例类定义的时候就实例化，本身就是线程安全的
```
class singleton{
protected:
    singleton(){}
private:
    static singleton* p;
public:
    static singleton* instance();
};

singleton* singleton::p = new singleton;  // 一创建类就创建实例
singletion* singleton::instance()
{
    return p;
}
```
#### 总结
+ 单例模式中的实例构造器可以设置为protected以允许子类派生
+	单例模式一般不需要支持拷贝构造函数和Clone接口，因为这有可能导致多个对象实例，与单例模式的初衷违背
+ 如何实现多线程环境下安全的单例？注意对双检查锁的正确实现
