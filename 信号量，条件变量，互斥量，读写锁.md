From: https://www.cnblogs.com/lustar/p/7689059.html

主要是为了控制两个进程按照我们想要的顺序进行，从而得到正确的结果
+ 竞争条件： 两个或者多个进程读写某些共享数据，最后的结果依赖于进程运行的精确时序 
+ 临界区： 把对共享内存进行访问的程序片段称作临界区，如果能使两个进程不可能同时处于临界区内，就能够避免竞争
>> 生产者-消费者问题（进程同步问题）

    有一个缓冲区，一个（或多个）进程在生产某种产品，它生产的东西会放入缓冲区内；
    一个（或多个）进程在消费产品，它会从缓冲区内取走产品。
    当缓冲区满时，生产者应当暂时停止生产；当缓冲区为空时，消费者应当暂时停止消费。

+ 信号量

信号量是一种数据结构，可以理解为一个用来计数的整数和一个队列。整数用来记录唤醒次数，而队列被用来记录因为该信号量
而阻塞的进程
```
信号量只支持两种操作： P/V操作

P操作： 测试并-1， P（signal1）, 如果signal1 大于 0， 那么把它减一，进程继续执行； 如果signal为0， 那么执行P操作
的进程将会被阻塞，从而变为阻塞态， 添加到因为signal1信号而阻塞的进程队列中

V操作：可以理解为+1并唤醒。V(signal1)后，如果signal1本来就大于0，那么执行+1；
如果有进程在该信号量上被阻塞，那么从队列中根据某种策略选择一个进程唤醒。如果多个进程在该信号量上阻塞，那么V操作后，signal1仍然可能为负数。

需要注意的是，P/V操作均应当是原子操作，即作为一个整体执行而不会被打断。
```

+ 互斥锁
```
互斥锁其实可以理解为一个简化的信号，他只有两种状态： 0 和 1.
互斥锁是用来解决进程（线程）互斥问题的。所谓进程互斥，就是两个进程实际上是一种互斥关系，两者不能同时访问共享资源。

互斥量和信号量原理比较类似，一旦一个线程获得了锁，那么其他线程就无法共享资源，
从而被阻塞，直到该线程交还出了锁的所有权，另一个线程才能获得锁

```
+条件变量
```
条件变量是另外一种同步机制，可以用于线程和管程中的进程互斥。通常与互斥量一起使用。

```
