
From: https://www.cnblogs.com/lustar/p/7689059.html

主要是为了控制两个进程按照我们想要的顺序进行，从而得到正确的结果
+ 竞争条件： 两个或者多个进程读写某些共享数据，最后的结果依赖于进程运行的精确时序 
+ 临界区： 把对共享内存进行访问的程序片段称作临界区，如果能使两个进程不可能同时处于临界区内，就能够避免竞争
>> 生产者-消费者问题（进程同步问题）

    有一个缓冲区，一个（或多个）进程在生产某种产品，它生产的东西会放入缓冲区内；
    一个（或多个）进程在消费产品，它会从缓冲区内取走产品。
    当缓冲区满时，生产者应当暂时停止生产；当缓冲区为空时，消费者应当暂时停止消费。

+ 信号量

信号量是一种数据结构，可以理解为一个用来计数的整数和一个队列。整数用来记录唤醒次数，而队列被用来记录因为该信号量
而阻塞的进程
```
信号量只支持两种操作： P/V操作

P操作： 测试并-1， P（signal1）, 如果signal1 大于 0， 那么把它减一，进程继续执行； 如果signal为0， 那么执行P操作
的进程将会被阻塞，从而变为阻塞态， 添加到因为signal1信号而阻塞的进程队列中

V操作：可以理解为+1并唤醒。V(signal1)后，如果signal1本来就大于0，那么执行+1；
如果有进程在该信号量上被阻塞，那么从队列中根据某种策略选择一个进程唤醒。如果多个进程在该信号量上阻塞，那么V操作后，signal1仍然可能为负数。

需要注意的是，P/V操作均应当是原子操作，即作为一个整体执行而不会被打断。
```

+ 互斥锁
```
互斥锁其实可以理解为一个简化的信号，他只有两种状态： 0 和 1.
互斥锁是用来解决进程（线程）互斥问题的。所谓进程互斥，就是两个进程实际上是一种互斥关系，两者不能同时访问共享资源。

互斥量和信号量原理比较类似，一旦一个线程获得了锁，那么其他线程就无法共享资源，
从而被阻塞，直到该线程交还出了锁的所有权，另一个线程才能获得锁

```
+条件变量
```
条件变量是另外一种同步机制，可以用于线程和管程中的进程互斥。通常与互斥量一起使用。
条件变量允许线程由于暂时没有达到的条件而阻塞。通常，等待另外一个线程完成该线程所需要的条件。条件到达时，另外一个线程
发送一个信号，唤醒该线程。
条件变量与互斥量一起使用，一般情况是，一个线程锁住一个互斥量，然后当它不能获得它期待的结果时，等待一个条件变量，最后另外一个
线程向它发送信号，使得它可以继续执行。
条件变量对应的一组操作是 pthread_cond_wait和pthread_cond_signal

条件变量与互斥量一起使用，一般情况是：一个线程锁住一个互斥量，然后当它不能获得它期待的结果时，等待一个条件变量；
最后另外一个线程向它发送信号，使得它可以继续执行。

需要注意的是，pthread_cond_wait会暂时解开持有的互斥锁

```
+读写锁
```
读写锁相对上面的问题会复杂一些，它被用来解决一个经典的问题，读者-写者问题

读写锁与互斥量类似，不过读写锁允许更高的并行性。互斥量要么是锁住状态要么是不加锁转态，而且一次只有一个线程可以对其加锁。

对于共享区域的读写规则如下：
1 只要有一个读者在读，后来的读者可以进入共享区直接读
2 只要有一个读者在读，写者就必须阻塞，直到最后一个读者离开
3 不考虑抢占式，写者在写时，即使读者到达，也会在就绪态等待


读写锁可以由三种状态：读模式下加锁，写模式下加锁状态，不加锁状态。
一次只有一个线程可以占有写模式的读写锁，但是多个线程可以同时占有读模式的读写锁

在读写锁是 写加锁状态 时， 在这个锁被解锁之前，所有试图对这个锁加锁的线程都会被阻塞。
在读写锁是 读加锁状态 时， 所有试图以读模式对它进行加锁的线程都可以得到访问权，但是
如果线程希望以写模式对此锁进行加锁，它必须阻塞知道所有的线程释放读锁。

虽然读写锁的实现各不相同，但当读写锁处于读模式锁住状态时，如果有另外的线程试图以写模式加锁，
读写锁通常会阻塞随后的读模式锁请求。这样可以避免读模式锁长期占用，而等待的写模式锁请求一直得不到满足。

读写锁非常适合对数据结构读的次数远大于写的情况。当读写锁在写模式下时，它所保护的数据结构就可以完全地
被修改，因为当前只有一个线程可以在写模式下拥有这个锁。当读写锁在读模式下时，只要线程获取了读模式下的
读写锁，该锁保护的数据结构可以被多个获得读模式锁的线程读取。

读写锁也叫做共享-独占锁：
当读写锁以读模式锁住时，它是以共享锁锁住的
当以写模式锁住时，它是以独占模式锁住的

总结：
1 互斥锁只用在同一个线程中，用来给一个需要对临界区进行读写的操作加锁
2 信号量与互斥量不同的地方在于，信号量一般在多个进程或者线程中，分别执行P/V操作
3 条件变量一般和互斥锁同时使用，或者用在管程中
4 互斥锁，条件变量都只用于同一个进程的各线程间，而信号量（有名信号量）用于进程间同步时，要求信号量
  建立在共享内存区
5 互斥锁是为上锁而优化的，条件变量是为等待而优化的；信号量即可用于上锁，也可用于等待，因此会有更多的开销和更高的复杂性

```
