#  比较排序算法

## 选择排序
## 插入排序
## 冒泡排序
## 希尔排序


## 归并排序 
```
// http://www.cnblogs.com/rio2607/p/4489893.html
void merge_sort(int *data, int start , int end, int *result){
  
    if( 1 == end - start){  //两个元素
         if( data[start] > data[end]){
             int temp = data[start];
             data[start] = data[end];
             data[end] = temp;
         }
         return; //递归终止
    }
    else if( 0 == end - start){
         return;  //递归终止
    }
    else{
         merge_sort(data, start, (end-start +1) / 2 + start, result); //左区间划分
         merge_sort(data, (end-start +1) / 2 +start + 1, result);   //右区间划分
         merge(data, start, end, result);  //归并
         for(int i = startl i <= end; ++i){
            data[i] = result[i];
         }
    }
}

void merge(int *data, int start, int end, int *result){
    int left_length = (end - start +1) / 2 + 1; //左区间的元素个数
    int left_index = start;
    int right_index = start + left_length;
    int result_index = start;
    
    //对已经排好序的左右区间进行合并
    //    [1 2 3 4]       [2 3 4 5]
    // left_index    right_index
    
    while(left_index < start + left_length && right_index < end + 1){
        if(data[left_index] <= data[right_index]){
            result[result_index++] = data[left_index++];
        }
        else{
            result[result_index++] = data[right_index++];
        }
    }
    while(left_index < start + left_length)
        result[result_index++] = data[left_index++];
    while(right_index < end +1)
        result[result_index++] = data[right_index++];
    
}
```

## 快速排序

快排是对归并排序的优化，归并 + 分治 的思想
```
template<typename T>
int __partition(T arr[], int l, int r){
    T v = arr[l]; //选取左边界作为基准
    int j = l;
    // [j i.......]
    // [5 2 3 4 6 7 8]
    //最后一个小于基准元素的下一个位置就是基准的位置
    //也就是从右向左第一个小于基准元素的位置
    // j 用来找到基准点合适的位置，只有小于基准的位置会发生交换
    
    for(int i = l+1; i <= r; i++){
        if(arr[i] < v){
             j ++;
             swap(arr[i], arr[j]);
        }
    }
    swap(arr[l],arr[j]);
    return j;    
}
template<typename T>
void quickSort(T arr[], int l, int r){
    if(l >= r)
    return;
    int p = __partition(arr,l,r); //放置正确位置
    quikSort(arr,l,p-1); //放在了p这个位置
    quikSort(arr,p+1,r);
}
```
注释： 手动排序，从右向左找第一个比基准元素小的位置
 在视觉上是从左向右找第一个比基准元素大的位置
```
[5 7 1 3 6 9 4]
[4 7 1 3 6 9  ]
[4   1 3 6 9 7]
[4 3 1   6 9 7]
[4 3 1 5 6 9 7]
```
#### STL sort底层实现原理：头文件<algorithm>中  using namespace std;
- 关系型容器有自动排序功能，底层采用红黑树，不需要用到sort算法
- 序列式容器 stack, queue, priority_queue 都有特定的出入口，不允许用户对元素排序
- vector 和deque 有排序算法
  数据量大时采用QuickSort排序算法，分段归并排序，一旦分段后的数据量小于某个门槛（16），为避免快排的递归调用带来过大的额外负荷，改用插入排序，如果 
  递归层次过深，还会改用堆排序，插入排序在元素近乎有序的时候表现更好。

- 默认情况下是对[first, last)区间的元素采用由小到大的方式排列
- 可以自定义比较函数，也可以调用stl提供的比较函数，less<T>(), greater<T>()
- 排序的区间可以必须是通过迭代器遍历（数组下标也算），迭代器的类型为随机迭代器
- 排序是通过多次内存的拷贝来实现的，所以链表不能适用STL算法sort来对其排序（next 指针修改问题）
- 对于链表的排序，STL list<T>可以实现对双端链表的排序

####  stl <algorithm> 中的sort算法实现，采用快排的思想，平均的时间复杂度是 N(logN);算法中还提供了其他的集中排序函数 sort_heap()  stable_sort ()  时间复杂度都在 N(logN)

## 堆排序

# 非比较排序算法

## 计数排序
## 桶排序
## 基数排序
