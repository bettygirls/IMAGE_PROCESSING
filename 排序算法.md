
#  比较排序算法

## 选择排序 
（从当前位置后半部分取出最小值，替换当前位置的值）
[______ I........]
```
//从小到大的排序
void selectionSort(int arr[], int n){
   for(int i =0; i < n; i++){
        // [i n) 里面的最小值
        int minIndex = i;  // 确定当前位置的的元素
        for(int j = i+1; j < n; j++){
              if(arr[j] < arr[minIndex])
                miIndex = j;
                swap(arr[i] , arr[minIndex]);
        }
   }

}
```
###### 优化选择排序



## 插入排序
动态保持前面的数有序，每次都调整当前位置之前的数组
[_______ i ........]
用另一个变量来遍历i之前的数，使i之前的数有序

```
template<typename>
void insertionSort(T arr[], int n){
  for(int i =1; i < n; i++){
      T e = arr[i];
      int j;
      //前一个数比较大的情况下，用当前数 替换前一个数
      for(j =i; j >0 && arr[j-1] > e; j--) 
           arr[j] = arr[j-1];
      //用当前数覆盖写入
      arr[j] = e;
  }
  return;
  }
```
#### BFPRT 
该算法是在快排的基础上做出改进，由于快排在选择基准元素的时候具有随机性。
```
//https://segmentfault.com/a/1190000008322873
int InsertSort(int array[]; int left, int right);  //返回中位数下标
int getPivotIndex(int array[], int left, int right); //返回中位数的中位数的下标
int Partition(int array[], int left, int right, int pivot_index); //利用中位数的中位数的下标进行划分
返回分界线下标

int BFPRT(int array[], int left, int right, const int &k); //求第k小，返回其位置的下标

int InsertSort(int array[], int left, int right){
    int temp;
    int j;
    for(int i = left +1; i <= right; i++){
        temp = array[i]; //要处理的位置
        j = i-1;
        while(j >= left && array[j] > temp)
           array[j+1]  = array[j--];
        array[j + 1] = temp;    
    }
    return ((right - left) >> 1) + left; // 返回中位数坐标
}

int getPivotIndex(int array[], int left, int right){
     if(right - left < 5){
         return InsertSort(array, left, right);  //组内排序用插排
     }  //递归退出条件
     int sub_right = left -1;
     for(int i = left; i + 4 <= right; i +=5){ //每5个为一组进行中位数的搜索
         int index = InsertSort(array, i, i+4); 用插入排序
         swap(array[++sub_right, array[index]]); //依次放在左侧
     }
     //sub_right 是中位数的右边界
     return BFPRT(array, left, sub_right, ((sub_right - left + 1)>> 1) + 1);
     
}
//利用中位数的下标进行划分返回分界线下标  快排
int Partition(int array[], int left, int right, int pivot_index){
     swap(array[pivot_index], array[right]);  //先把基准放在最后
     
     int divide_index = left;

     for(int i = left; i < right; i++){ //除基准之外的元素
         if(array[i] < array[right]){    //比基准小的放在基准的前面
             swap(array[divide_index++], array[i]);
         }
     }
     swap(array[divide_index], array[right]);   //把基准放在原来的位置
     return divide_index;     
}

int BFPRT(int array[], int left, int right, const int &k){
    int pivot_index = getPivotIndex(array,left,right);   //中位数的中位数的下标
    int divide_index = Partition(array, left, right, pivot_index);  //进行划分，返回划分边界
    int num = divide_index - left +1;
    if(num == k)
        return divide_index;
    else if(num > k)
        return BFPRT(array, left, divide_index -1, k);
     else
        return BFPRT(array, divide_index +1, right, k -num);
}


```
注释： BFPRT 算法的精髓在于首先获得中位数的中位数的时候， 将小于这个数的元素放在左边，大于这个数的元素放在右边
此时比较中位数和k的大小，可以排除 1/2  的元素
```
s s s s * * * * * * 
s s s s * * * * * * 
# # # # m # # # # # 
l l l l l l l l l l 
l l l l l l l l l l 

```


## 冒泡排序
冒泡排序使最常见的两两元素比较大小，然后交换顺序的方法，每次只能得到当前最值，放在最后，所有的位置
标记都是在遍历完成之后，在内循环外面进行标记，属于全局范围的排序，缩小排序范围
[----------------------max]
```
template<typename T>
void bubuleSort(T arr[], int n){
   bool swapped;
   do{
      swapped = false;
      for(int i = 1; i < n; i++){
         if(arr[i -1] > arr[i]){
             swap(arr[i-1] , arr[i]);
             swapped = true;
         }
      }
      n--; //最后一个元素已经安置好，则进行丢弃
   }while(swapped);

}
```
#### 改进冒泡排序
```
templat<typename T>
void bubbleSort2(T arr[], int n){
   int newn;
   do{
      newn = 0;
      for(int i =1; i < n; i++){
          if(arr[i-1] > arr[i]){
             swap(arr[i -1] , arr[i]);
             newn = i;  //标记最后发生交换的位置
          }
      }
      n = newn; // 跳过未发生交换的位置
   }while(newn > 0)
}
```


## 希尔排序


## 归并排序 
```
// http://www.cnblogs.com/rio2607/p/4489893.html
void merge_sort(int *data, int start , int end, int *result){
  
    if( 1 == end - start){  //两个元素
         if( data[start] > data[end]){
             int temp = data[start];
             data[start] = data[end];
             data[end] = temp;
         }
         return; //递归终止
    }
    else if( 0 == end - start){
         return;  //递归终止
    }
    else{
         merge_sort(data, start, (end-start +1) / 2 + start, result); //左区间划分
         merge_sort(data, (end-start +1) / 2 +start + 1, result);   //右区间划分
         merge(data, start, end, result);  //归并
         for(int i = startl i <= end; ++i){
            data[i] = result[i];
         }
    }
}

void merge(int *data, int start, int end, int *result){
    int left_length = (end - start +1) / 2 + 1; //左区间的元素个数
    int left_index = start;
    int right_index = start + left_length;
    int result_index = start;
    
    //对已经排好序的左右区间进行合并
    //    [1 2 3 4]       [2 3 4 5]
    // left_index    right_index
    
    while(left_index < start + left_length && right_index < end + 1){
        if(data[left_index] <= data[right_index]){
            result[result_index++] = data[left_index++];
        }
        else{
            result[result_index++] = data[right_index++];
        }
    }
    while(left_index < start + left_length)
        result[result_index++] = data[left_index++];
    while(right_index < end +1)
        result[result_index++] = data[right_index++];
    
}
```

## 快速排序

快排是对归并排序的优化，归并 + 分治 的思想
```
template<typename T>
int __partition(T arr[], int l, int r){

T v = arr[l]; //选取左边界作为基准
    int j = l;
    // [j i.......]
    // [5 2 3 4 6 7 8]
    //最后一个小于基准元素的下一个位置就是基准的位置
    //也就是从右向左第一个小于基准元素的位置
    // j 用来找到基准点合适的位置，只有小于基准的位置会发生交换
    
    for(int i = l+1; i <= r; i++){
        if(arr[i] < v){
             j ++;
             swap(arr[i], arr[j]);
        }
    }
    swap(arr[l],arr[j]);
    return j;    
}
template<typename T>
void quickSort(T arr[], int l, int r){
    if(l >= r)
    return;
    int p = __partition(arr,l,r); //放置正确位置
    quikSort(arr,l,p-1); //放在了p这个位置
    quikSort(arr,p+1,r);
}
```
注释： 手动排序，从右向左找第一个比基准元素小的位置
 在视觉上是从左向右找第一个比基准元素大的位置
```
[5 7 1 3 6 9 4]
[4 7 1 3 6 9  ]
[4   1 3 6 9 7]
[4 3 1   6 9 7]
[4 3 1 5 6 9 7]
```
#### STL sort底层实现原理：头文件<algorithm>中  using namespace std;
- 关系型容器有自动排序功能，底层采用红黑树，不需要用到sort算法
- 序列式容器 stack, queue, priority_queue 都有特定的出入口，不允许用户对元素排序
- vector 和deque 有排序算法
  数据量大时采用QuickSort排序算法，分段归并排序，一旦分段后的数据量小于某个门槛（16），为避免快排的递归调用带来过大的额外负荷，改用插入排序，如果 
  递归层次过深，还会改用堆排序，插入排序在元素近乎有序的时候表现更好。

- 默认情况下是对[first, last)区间的元素采用由小到大的方式排列
- 可以自定义比较函数，也可以调用stl提供的比较函数，less<T>(), greater<T>()
- 排序的区间可以必须是通过迭代器遍历（数组下标也算），迭代器的类型为随机迭代器
- 排序是通过多次内存的拷贝来实现的，所以链表不能适用STL算法sort来对其排序（next 指针修改问题）
- 对于链表的排序，STL list<T>可以实现对双端链表的排序

####  stl <algorithm> 中的sort算法实现，采用快排的思想，平均的时间复杂度是 N(logN);算法中还提供了其他的集中排序函数 sort_heap()  stable_sort ()  时间复杂度都在 N(logN)

## 堆排序

#### 二叉堆的定义
二叉堆是完全二叉树或者是近似完全二叉树
1．父结点的键值总是大于或等于（小于或等于）任何一个子节点的键值。
2．每个结点的左子树和右子树都是一个二叉堆（都是最大堆或最小堆）。
当父结点的键值总是大于或等于任何一个子节点的键值时为最大堆。当父结点的键值总是小于或等于任何一个子节点的键值时为最小堆。
堆的存储  


数组， i结点的父节点的下标是(i - 1) /2 , 它的左右子结点下标分别是 2*i  和 2*i +2
- 堆建立：
- 元素插入：新元素被插入表层，然后进行调整
- 元素删除：删除总是发生在根结点处  

每次插入元素，新的数据放在数组最后，
```

```


# 非比较排序算法

## 计数排序
## 桶排序
## 基数排序
