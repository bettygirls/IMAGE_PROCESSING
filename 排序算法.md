#  比较排序算法

## 选择排序
## 插入排序
## 冒泡排序
## 希尔排序


## 归并排序 
```
// http://www.cnblogs.com/rio2607/p/4489893.html
void merge_sort(int *data, int start , int end, int *result){
  
    if( 1 == end - start){  //两个元素
         if( data[start] > data[end]){
             int temp = data[start];
             data[start] = data[end];
             data[end] = temp;
         }
         return; //递归终止
    }
    else if( 0 == end - start){
         return;  //递归终止
    }
    else{
         merge_sort(data, start, (end-start +1) / 2 + start, result); //左区间划分
         merge_sort(data, (end-start +1) / 2 +start + 1, result);   //右区间划分
         merge(data, start, end, result);  //归并
         for(int i = startl i <= end; ++i){
            data[i] = result[i];
         }
    }
}

void merge(int *data, int start, int end, int *result){
    int left_length = (end - start +1) / 2 + 1; //左区间的元素个数
    int left_index = start;
    int right_index = start + left_length;
    int result_index = start;
    
    //对已经排好序的左右区间进行合并
    //    [1 2 3 4]       [2 3 4 5]
    // left_index    right_index
    
    while(left_index < start + left_length && right_index < end + 1){
        if(data[left_index] <= data[right_index]){
            result[result_index++] = data[left_index++];
        }
        else{
            result[result_index++] = data[right_index++];
        }
    }
    while(left_index < start + left_length)
        result[result_index++] = data[left_index++];
    while(right_index < end +1)
        result[result_index++] = data[right_index++];
    
}
```

## 快速排序

快排是对归并排序的优化，归并 + 分治 的思想
```
template<typename T>
int __partition(T arr[], int l, int r){
    T v = arr[l]; //选取左边界作为基准
    int j = l;
    // [j i.......]
    // [5 2 3 4 6 7 8]
    //最后一个小于基准元素的下一个位置就是基准的位置
    //也就是从右向左第一个小于基准元素的位置
    // j 用来找到基准点合适的位置，只有小于基准的位置会发生交换
    
    for(int i = l+1; i <= r; i++){
        if(arr[i] < v){
             j ++;
             swap(arr[i], arr[j]);
        }
    }
    swap(arr[l],arr[j]);
    return j;    
}
template<typename T>
void quickSort(T arr[], int l, int r){
    if(l >= r)
    return;
    int p = __partition(arr,l,r); //放置正确位置
    quikSort(arr,l,p-1); //放在了p这个位置
    quikSort(arr,p+1,r);
}
```
注释： 手动排序，从右向左找第一个比基准元素小的位置
 在视觉上是从左向右找第一个比基准元素大的位置
```
[5 7 1 3 6 9 4]
[4 7 1 3 6 9  ]
[4   1 3 6 9 7]
[4 3 1   6 9 7]
[4 3 1 5 6 9 7]
```
STL sort底层实现原理：


## 堆排序

# 非比较排序算法

## 计数排序
## 桶排序
## 基数排序
