 ##### 智能指针 
堆内存的申请和释放都是程序员管理，为了防止忘记释放造成内存泄漏，或者二次释放，
所以引入智能指针来管理内存

+ 理解
1  智能指针是利用了一种叫做RAII（资源获取即初始化）的技术对普通的指针进行封装，
这使得智能指针实质是一个对象，行为表现的却像一个指针。
2智能指针的作用是防止忘记调用delete释放内存和程序异常的进入catch块忘记释放内存。
另外指针的释放时机也是非常有考究的，多次释放同一个指针会造成程序崩溃，这些都可以通过智能指针来解决。
3智能指针还有一个作用是把值语义转换成引用语义。

#### 头文件 #include<memory>
#### shared_ptr, unique_ptr, weak_ptr

+ shared_ptr  

  多个指针指向相同的对象，使用引用计数，每个shared_ptr的拷贝都指向相同的内存，每使用一次，内部的引用计数加1
  ，每析构一次，内部的引用计数减1，减为0的时候，自动删除所指向的堆内存，shared_ptr内部的引用计数是线程安全的，
  但是对象的读取需要加锁。
```
1 初始化。
智能指针是个模板类，可以指定类型，传入指针通过构造函数初始化。
                  也可以使用make_shared函数初始化。
不能将指针直接赋值给一个智能指针，一个是类，一个是指针。
例如std::shared_ptr<int> p4 = new int(1);的写法是错误的

2 拷贝和赋值。
拷贝使得对象的引用计数增加1，赋值使得原对象引用计数减1，当计数为0时，自动释放内存。
后来指向的对象引用计数加1，指向后来的对象。

3 get函数获取原始指针
注意不要用一个原始指针初始化多个shared_ptr，否则会造成二次释放同一内存

4* 注意避免循环引用，shared_ptr的一个最大的陷阱是循环引用，循环，循环引用会导致堆内存无法正确释放，导致内存泄漏。
循环引用在weak_ptr中介绍。
```
```
#include <iostream>
#include <memory>

int main() {
	{
		int a = 10;
		std::shared_ptr<int> ptra = std::make_shared<int>(a);
		std::shared_ptr<int> ptra2(ptra); //copy
		std::cout << ptra.use_count() << std::endl;

		int b = 20;
		int *pb = &a;
		//std::shared_ptr<int> ptrb = pb;  //error
		std::shared_ptr<int> ptrb = std::make_shared<int>(b);
	    ptra2 = ptrb; //assign
		pb = ptrb.get(); //获取原始指针

		std::cout << ptra.use_count() << std::endl;
		std::cout << ptrb.use_count() << std::endl;
	}
}
```
+ unique_ptr  

unique_ptr“唯一”拥有其所指对象，同一时刻只能有一个unique_ptr指向给定对象（通过禁止拷贝语义、只有移动语义来实现）。
相比与原始指针unique_ptr用于其RAII的特性，使得在出现异常的情况下，动态资源能得到释放。
unique_ptr指针本身的生命周期：从unique_ptr指针创建时开始，直到离开作用域。

离开作用域时，若其指向对象，则将其所指对象销毁(默认使用delete操作符，用户可指定其他操作)。

unique_ptr指针与其所指对象的关系：在智能指针生命周期内，可以改变智能指针所指对象，如创建智能指针时通过构造函数指定、通过reset方法重新指定、
通过release方法释放所有权、通过移动语义转移所有权
```
#include <iostream>
#include <memory>

int main() {
	{
		std::unique_ptr<int> uptr(new int(10));  //绑定动态对象
		//std::unique_ptr<int> uptr2 = uptr;  //不能賦值
		//std::unique_ptr<int> uptr2(uptr);  //不能拷貝
		std::unique_ptr<int> uptr2 = std::move(uptr); //轉換所有權
		uptr2.release(); //释放所有权
	}
	//超過uptr的作用域，內存釋放
}
```
+ weak_ptr  

weak_ptr是为了配合shared_ptr而引入的一种智能指针，因为它不具有普通指针的行为，没有重载operator*和->,它的最大作用在于协助shared_ptr工作，像旁观者那样观测资源的使用情况。
weak_ptr可以从一个shared_ptr或者另一个weak_ptr对象构造，获得资源的观测权。

*但weak_ptr没有共享资源，它的构造不会引起指针引用计数的增加。

使用weak_ptr的成员函数use_count()可以观测资源的引用计数，
另一个成员函数expired()的功能等价于use_count()==0,但更快，表示被观测的资源(也就是shared_ptr的管理的资源)已经不复存在。
weak_ptr可以使用一个非常重要的成员函数lock()从被观测的shared_ptr获得一个可用的shared_ptr对象， 从而操作资源。
但当expired()==true的时候，lock()函数将返回一个存储空指针的shared_ptr。
```
#include <iostream>
#include <memory>

int main() {
	{
		std::shared_ptr<int> sh_ptr = std::make_shared<int>(10);
		std::cout << sh_ptr.use_count() << std::endl;

		std::weak_ptr<int> wp(sh_ptr);
		std::cout << wp.use_count() << std::endl;

		if (!wp.expired()){  //如果引用计数为0的时候
			std::shared_ptr<int> sh_ptr2 = wp.lock(); //get another shared_ptr
			*sh_ptr = 100;
			std::cout << wp.use_count() << std::endl;
		}
	}
	//delete memory
}
```
+ 循环引用的例子
```
#include <iostream>
#include <memory>

class Child;
class Parent;

class Parent {
private:
    //std::shared_ptr<Child> ChildPtr; *** 
    std::weak_ptr<Child> ChildPtr;  这里应该为weak_ptr
public:
    void setChild(std::shared_ptr<Child> child) {
        this->ChildPtr = child;
    }

    void doSomething() {
        //new shared_ptr
        if (this->ChildPtr.lock()) {

        }
    }

    ~Parent() {
    }
};

class Child {
private:
    std::shared_ptr<Parent> ParentPtr;
public:
    void setPartent(std::shared_ptr<Parent> parent) {
        this->ParentPtr = parent;
    }
    void doSomething() {
        if (this->ParentPtr.use_count()) {

        }
    }
    ~Child() {
    }
};

int main() {
    std::weak_ptr<Parent> wpp;
    std::weak_ptr<Child> wpc;
    {
        std::shared_ptr<Parent> p(new Parent);
        std::shared_ptr<Child> c(new Child);
        p->setChild(c);
        c->setPartent(p);
        wpp = p;
        wpc = c;
        std::cout << p.use_count() << std::endl; // 2
        std::cout << c.use_count() << std::endl; // 1
    }
    std::cout << wpp.use_count() << std::endl;  // 0
    std::cout << wpc.use_count() << std::endl;  // 0
    return 0;
}
```
