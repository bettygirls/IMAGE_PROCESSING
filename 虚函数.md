#### 虚函数

1 本质上是指针，要通过监视变量查看  

2 如果类中有虚函数，类大小要加4字节，一个指针大小  

3 类的构造函数不可以是虚函数，编译无法通过，因为子类对象中的父类拷贝无法完成初始化  

4 使用多态继承，父类析构函数必须为虚函数，不然不会调用子类析构函数，会造成内存泄漏


若存在类的继承关系,而且基类指针指向派生类对象时,一般需要将析构函数声明为虚函数,
不然在使用基类指针进行析构时会无法调用派生类的析构函数而造成内存泄漏等问题 。
如果不存在继承关系,而且不需要使用多态的特性时,就不要将析构函数声明为虚函数,
因为虚函数本身实现需要额外的花销(如vptr),在类本身比较小时,会造成很大额外花销的比例. 

#### 单继承下的虚函数表
```
class A{
  public:
       virtual void func(){
           cout<< "A::func"<<endl;
       }
       virtual void funcA(){
           cout<< "A::funcA"<<endl;
       }
};

class B : public A{
  public:
       virtual void func(){
           cout<< "B::func"<<endl;
       }
       virtual void funcB(){
           cout<< "B::funcB"<<endl;
       }
};

class C : public A{
  public:
       virtual void func(){
           cout<< "C::func"<<endl;
       }
       virtual void funcC(){
           cout<< "C::funcC"<<endl;
       }
};
```
```
A 基类：有两个虚函数 func 和funcA
B继承A：虚函数实现func并定义了自己的虚函数funcB
C继承A：虚函数实现func并定义自己的虚函数funcC
```
```
单继承情况下：（虚函数表的存放情况->存放虚函数地址）
1 先基类的虚函数
2 再派生类的虚函数
3 存在覆盖的话，派生类的虚函数占据覆盖的基类的虚函数的位置

```
+ 1 各个虚函数表中的虚函数地址是如何存放的？

```
A 的虚表：
A::func
A::funcA

B 的虚表：
B::func    //B的func 与A中的func形成覆盖，所以这里是B的函数
A::funcA
B::funcB

C的虚表：
C::func    //B的func 与A中的func形成覆盖，所以这里是B的函数
A::funcA
C::funcC
```
+ 2 三个类中共有多少个虚函数表？
```
三个类中都有虚函数，所以三个类均有各自独立的虚函数表
```
+ 3 B和C的虚函数表有没有关系？
```
B、C各自拥有自己的虚函数表，互不影响
```
+ 4 是不是每个对象都有一个虚函数表，虚函数表存放在哪？
```
类的对象只存储指向虚函数表的指针vfptr（一般存储在对象内存布局的最前面），
虚函数表只有一份，为所有对象所共享，
vtable在Linux/Unix中存放在可执行文件的只读数据段中(rodata)，
而微软的编译器将虚函数表存放在常量段
```

#### 多继承情况下虚函数表
```
class A{
  public:
       virtual void func(){
           cout<< "A::func"<<endl;
       }
       virtual void funcA(){
           cout<< "A::funcA"<<endl;
       }
  private:
      int a;
};

class B {
  public:
       virtual void func(){
           cout<< "B::func"<<endl;
       }
       virtual void funcB(){
           cout<< "B::funcB"<<endl;
       }
   private:
       int b;
};

class C : public A, public B{
  public:
       virtual void func(){
           cout<< "C::func"<<endl;
       }
       virtual void funcC(){
           cout<< "C::funcC"<<endl;
       }
   private:
       int c;
};
```
```
多继承下的虚函数表：——>(有几个基类就有几张虚函数表——派生类的虚函数存放在先声明的基类的虚函数表中)
1：先声明的基类的虚函数表
   该类的成员变量（int a）
2: 后声明的基类的虚函数表
   该类的成员变量（int b）
3 派生类中与基类造成覆盖的——>分别占据相应的位置——>C::funC分别于两个基类的
   虚函数形成覆盖（分别所以占据两者的位置）
4  派生类中未覆盖的，放在首先声明的基类的虚函数表的后面——>C::funC

```
```
多继承条件下的虚函数表：
C::func  //形成覆盖  3
A::funA
C::funC  // 未覆盖  4
--------------
C::func  //形成覆盖 3
B::funcB

```
+ 对象C的内存分布
```
vfptr ————>   C::func()
              A::funcA()
              c::funcC()
int a
vfptr —————>  C::func()
              B::funcB()
int b
int c
         
```

+ 1 通过pa,pb,pc分别能够访问那些函数？
基类指针指向派生类的对象，通过该基类指针所能访问的函数受类型的限制（运行时调用哪个函数受多态的影响）

多继承条件下，基类指针指向派生类后基类指针所能访问的函数：
```
C c;
A *pa = &c;
B *pb = &c;
C *pc = &c;
基类指针Pa所能调用的函数：
pa->func();    C::func
pa->funcA();   A::funcA

基类指针pd所能调用的函数：
pb->func();    C::func
pb->funcB();   B::funcB

派生类指针pc所能调用的函数：
pc->func();    C::func
pc->funcA();   A::funcA
pc->funcB();   B::funcB
pc->funcC();   C::funcC

```
+ 2 pa,pb,pc 的关系
```
pa和pc的值相同，都是对象c的首地址，pb和pa至今相差四个字节（int  a造成的-->观察上图的内存空间分配）
```
+ 3  pa->func() 访问的是哪个类里的func
```
由于多态，会访问C类的func
```
+ 4 如何通过pa访问A中的func
```
通过添加作用域，pa->A::func()
```

#### 多继承条件下，基类指针指向派生类对象后，基类指针之间强制类型转化后，所能访问的函数
```
void test()
{
  C c;
  A *pa = &c;
  B *pb = &c;
  C *pc = &c;
  pa = reinterpret_cast<A*>(pb);
  pa->func();
  pa->funcA();
}
```
+ 输出
```
C::func
B::funcB
```
+ 解释
```
reinterpret类型转换运算符，只是简单的从一个指针到别的指针的二进制拷贝，pa,pb所指的内存空间如图，
当运行pa->func()时，多态性显示C：：func 当走到pa->funcA时，
根据汇编代码，在虚表中查找偏移4字节对应的函数，也就是B：：funcB()函数

```
#### 虚函数的作用
```
虚函数的作用是为了实现对基类与派生类中的虚函数成员的迟后联编，
而纯虚函数是表明不具体实现的虚函数成员，即纯虚函数无实现代码。其作用仅仅是为其派生类提过一个统一的构架，具体实现在派生类中给出。
用基类的指针或者引用调用派生类中的函数，实现动态联编

```
