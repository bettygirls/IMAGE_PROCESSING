
#### new 和 malloc

#### malloc 动态内存分配  和  free
头文件<stdlib.h> 
```
分配成功返回指向被分配内存的指针，分配失败返回空指针NULL ,不用的时候要用free函数
malloc 向系统申请分配指定size个字节的内存空间，返回类型是 void* 类型。void* 表示未确定类型的指针。
C,C++规定，void* 类型可以强制转换为任何其它类型的指针。 
用完要用free释放

注意事项
1）申请了内存空间后，必须检查是否分配成功。
2）当不需要再使用申请的内存时，记得释放；释放后应该把指向这块内存的指针指向NULL，防止程序后面不小心使用了它。 
3）这两个函数应该是配对。如果申请后不释放就是内存泄露；如果无故释放那就是什么也没有做。释放只能一次，如果释放两次及两次以上会出现错误（释放空指针例外，释放空指针其实也等于啥也没做，所以释放空指针释放多少次都没有问题）。
4）虽然malloc()函数的类型是(void *),任何类型的指针都可以转换成(void *),但是最好还是在前面进行强制类型转换，因为这样可以躲过一些编译器的检查。

malloc()到底从哪里得到了内存空间？
答案是从堆里面获得空间。也就是说函数返回的指针是指向堆里面的一块内存。操作系统中有一个记录空闲内存地址的链表。当操作系统收到程序的申请时，就会遍历该链表，然后就寻找第一个空间大于所申请空间的堆结点，然后就将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。
```

#### new 和 delete
```
用new和delete动态创建和释放数组或单个对象。

动态创建对象时，只需指定其数据类型，而不必为该对象命名，new表达式返回指向该新创建对象的指针，我们可以通过指针来访问此对象。
int *pi=new int;
这个new表达式在堆区中分配创建了一个整型对象，并返回此对象的地址，并用该地址初始化指针pi 。

-----------------------动态创建对象的初始化------------------------------
动态创建的对象可以用初始化变量的方式初始化。
int *pi=new int(100); //指针pi所指向的对象初始化为100
string *ps=new string(10,’9’);//*ps 为“9999999999”
如果不提供显示初始化，对于类类型，用该类的默认构造函数初始化；而内置类型的对象则无初始化。
也可以对动态创建的对象做值初始化：
int *pi=new int( );//初始化为0
int *pi=new int;//pi 指向一个没有初始化的int
string *ps=new string( );//初始化为空字符串 （对于提供了默认构造函数的类类型，没有必要对其对象进行值初始化）

-------------------------撤销动态创建的对象--------------------------------
delete表达式释放指针指向的地址空间。
delete pi ;// 释放单个对象
delete [ ]pi;//释放数组
如果指针指向的不是new分配的内存地址，则使用delete是不合法的。

一旦删除了指针所指的对象，立即将指针置为0

-------------------------区分0值指针和NULL指针-----------------------------
0值指针是值为0的指针，可以是任何一种指针类型
空指针，是一种编程概念，空指针是人认为的指针不提供任何地址讯息

new 失败的时候，返回std::bad_alloc 或者返回0
```
#### new 和 malloc 的区别
````
1 new 返回指定类型的指针，并且可以自动计算所需要的大小
  malloc 需要我们计算字节数，并在返回后强行转换为实际类型的指针
  int* p; 
  p = (int*) malloc(sizeof(int)*128);

2 malloc 只管分配内存，并不能对所得的内存进行初始化，所以得到的一片新内存中，其值将是随机的
  除了分配及最后释放的方法不一样以外，通过malloc或new得到的指针，在其他操作上一致
  
3 malloc/free 是C/C++语言的标准库函数，new/delete是C++运算符 ，都可以用于申请动态内存和释放内存

4 对于非内粗数据类型的对象而言，malloc/free吴曼满足动态对象的要求，对象在创建的同时要自动执行构造函数
在消亡之前要自动执行析构函数，malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和
析构函数的任务强加于malloc/free
因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。注意new/delete不是库函数。
我们不要企图用malloc/free来完成动态对象的内存管理，应该用new/delete。由于内部数据类型的“对象”没有构造与析构的过程，对它们而言malloc/free和new/delete是等价的。

既然new/delete的功能完全覆盖了malloc/free，为什么C++不把malloc/free淘汰出局呢？
这是因为C++程序经常要调用C函数，而C程序只能用malloc/free管理动态内存。
如果用free释放“new创建的动态对象”，那么该对象因无法执行析构函数而可能导致程序出错。如果用delete释放“malloc申请的动态内存”，结果也会导致程序出错，但是该程序的可读性很差。所以new/delete必须配对使用，malloc/free也一样。
````


