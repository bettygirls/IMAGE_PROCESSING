
# 死锁

## 定义
   在一个进程集合中，所有的进程都在等待只能由该进程集合中的其他进程才能引发的事件，这就是死锁
   
## 1 死锁发生的条件
###  （1） 互斥条件
      每个资源要么已经分配给一个进程要么是可用的，资源非共享
      
###  （2）请求和保持
      已经得到资源的进程还能继续请求新的资源
      
###  （3）不可剥夺
      当一个资源分配给一个进程后，其他需要该资源的进程不能强制获得该资源，除非该资源的当前资源的占有
      者显式地释放该资源
      
###  （4）循环等待
     死锁发生时，系统中一定有两个或两个以上的进程组成的一条环路，环路上的每个进程都在等待下一个进程
     所占有的资源


     
## 2 死锁的预防

### （1）破坏互斥条件

     如果允许系统资源都能共享使用，则系统不会进入死锁状态。但有些资源根本不能同时访问，如打印机等临界资源只能互斥使用。
     所以，破坏互斥条件而预防死锁的方法__不太可行__，而且在有的场合应该保护这种互斥性。
     因为CPU是共享型资源，所以不存在死锁
###  （2）破坏不剥夺条件
     当一个已保持了某些不可剥夺资源的进程，请求新的资源而得不到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请。
     这意味着，一个进程已占有的资源会被暂时释放，或者说是被剥夺了，或从而破坏了不可剥夺条件。 
     该策略实现起来比较复杂，释放已获得的资源可能造成前一阶段工作的失效，反复地申请和释放资源会增加系统开销，降低系统吞吐量（TPS）。
     这种方法常用于__状态易于保存和恢复的资源__，如CPU的寄存器及内存资源，一般不能用于打印机之类的资源。
###  （3）破坏请求和保持条件
     釆用预先静态分配方法，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不把它投入运行。
     一旦投入运行后，这些资源就一直归它所有，也不再提出其他资源请求，这样就可以保证系统不会发生死锁。 
     这种方式实现简单，但缺点也显而易见，系统资源被严重浪费，其中有些资源可能仅在运行初期或运行快结束时才使用，甚至根本不使用。
     而且还会导致__“饥饿”__现象，当由于个别资源长期被其他进程占用时，将致使等待该资源的进程迟迟不能开始运行。
### （4）破坏循环等待条件
     为了破坏循环等待条件，可釆用__顺序资源分配法__。
     首先给系统中的资源编号，规定每个进程，必须按编号递增的顺序请求资源，同类资源一次申请完。
     也就是说，只要进程提出申请分配资源Ri，则该进程在以后的资源申请中，只能申请编号大于Ri的资源。 
     这种方法存在的问题是，编号必须相对稳定，这就__限制了新类型设备的增加__；尽管在为资源编号时已考虑到大多数作业实际使用这些资源的顺序，
     但也经常会发生作业使用资源的顺序与系统规定顺序不同的情况，造成资源的浪费；
     此外，这种按规定次序申请资源的方法，也必然会给用户的编程带来麻烦。
     
     
##  3  死锁避免
    __避免死锁同样是属于事先预防的策略，但并不是事先釆取某种限制措施破坏死锁的必要条件，而是在资源动态分配过程中，防止系统进入不安全状态，
    以避免发生死锁。这种方法所施加的限制条件较弱，可以获得较好的系统性能。__
###  （1）系统安全状态
     避免死锁的方法中，允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次资源分配的安全性。
     若此次分配不会导致系统进入不安全状态，则将资源分配给进程； 否则，让进程等待。 
     所谓安全状态，是指系统能按某种进程推进顺序( P1, P2, ..., Pn)，为每个进程Pi分配其所需资源，直至满足每个进程对资源的最大需求，使每个
     进程都可顺序地完成。此时称 P1, P2, ..., Pn 为安全序列。如果系统无法找到一个安全序列，则称系统处于不安全状态。 
     __并非所有的不安全状态都是死锁状态，但当系统进入不安全状态后，便可能进入死锁状态；__反之，只要系统处于安全状态，系统便可以避免进入死锁状态。
###  （2）银行家算法
      银行家算法是最著名的死锁避免算法。
      它提出的思想是：把操作系统看做是银行家，操作系统管理的资源相当于银行家管理的资金，进程向操作系统请求分配资源相当于用户向银行家贷款。
      操作系统按照银行家制定的规则为进程分配资源，当进程首次申请资源时，要测试该进程对资源的最大需求量，如果系统现存的资源可以满足它的最大需求量
      则按当前的申请量分配资源，否则就推迟分配。
      当进程在执行中继续申请资源时，先测试该进程已占用的资源数与本次申请的资源数之和是否超过了该进程对资源的最大需求量。
      若超过则拒绝分配资源，若没有超过则再测试系统现存的资源能否满足该进程尚需的最大资源量，若能满足则按当前的申请量分配资源，否则也要推迟分配
      
##  4 死锁检测
      
      __死锁预防和避免算法__，都是在为进程分配资源时施加限制条件或进行检测，若系统为进程分配资源时不采取任何措施，则应该提供死锁检测和解除手段__
      可以通过资源分配图简化的方法来检测系统状态是否是死锁状态：
      a   在资源分配图中，找出既不阻塞又不是孤点的进程Pi（ 即找出一条有向边与它相连，且该有向边对应资源的申请数量小于等于系统中已有空闲资源数量。
      若所有的连接该进程的边均满足上述条件，则这个进程能继续运行直至完成，然后释放它所占有的所有资源）。
      消去它所有的请求边和分配边，使之成为孤立的结点。
      b    进程Pi所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变为非阻塞进程。
      S 为死锁的条件是当且仅当S状态的资源分配图是不可完全简化的，该条件为死锁定理
      
## 5 死锁的解除
     
###  （1）资源剥夺法
          挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源，而处于资源匮乏的状态。 
###  （2）撤销进程法
          强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程优先级和撤销进程代价的高低进行。 
###  （3）进程回退法
          让一（多）个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点
      
      
      

      



