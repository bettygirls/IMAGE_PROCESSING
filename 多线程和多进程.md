#### 多线程使用场景
```
IO是一个通用的概念，即数据从一个地方移动到另一个地方，对一个实体来说，可以看成数据从外部进入，以及从实体输出到外部。 
具体来说，常见的IO请求有网络IO，磁盘IO。 

那么因为CPU的工作频率远远快过和其连接的外部硬件，例如磁盘，所以CPU在IO的时候经常会需要等待外部硬件完成当前任务，
完成之后，才能进行下一个任务，这种情况常常称为IO阻塞，即CPU直到等待IO操作返回前，不能继续运行。IO阻塞对于CPU强大的运算能力是一个巨大的浪费。

所以有了多线程，多线程是同步运行的多个任务。不过由于CPU核数的问题，许多线程实际上并不是真正并行而只是通过快速切分时间片来模拟的。
简单来说就是你执行一点，我执行一点，来回切换，创造出一种同时运行任务的假象。
多线程的底层机制是由操作系统实现的，当一个线程遇到IO阻塞时，例如读写文件，操作系统可能会暂时挂起该线程，从而让其他线程优先执行，
也就是将多出来的时间片切分给其他的线程，直到等待该线程的IO操作返回，再重新调度该线程运行。
```
+ CPU密集  没有阻塞 CPU一直在运行
```
CPU密集的意思是该任务需要大量的运算，而没有阻塞，CPU一直全速运行。 
CPU密集任务只有在真正的多核CPU上才可能得到加速(通过多线程)，而在单核CPU上，无论你开几个模拟的多线程，该任务都不可能得到加速，因为CPU总的运算能力就那些。
```
+ IO密集  大量的阻塞，浪费CPU
```
IO密集型，即该任务需要大量的IO，即大量的阻塞。在单线程上运行IO密集型的任务会导致浪费大量的CPU运算能力浪费在等待。
所以在IO密集型任务中使用多线程可以大大的加速程序运行，即时在单核CPU上，这种加速主要就是利用了被浪费掉的阻塞时间。 

除了同步IO之外，系统可能还支持异步IO，即IO不阻塞，对IO设备发出读写命令之后立即返回执行下一条命令，
而IO设备的返回结果则在将来未知的某个时间点通过信号来回调。这也是nodeJS底层的实现机制。

I/O密集型操作。硬盘、网卡、声卡、显卡等都是。
涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。
对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。
IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率。
对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差。 
```

#### 多进程和多线程的区别
```
进程它是具有独立地址空间的，优点就是隔离度好,稳定，因为它是操作系统管理的，进程和进程之间是逻辑隔离的，只要操作系统不出问题的话，一个进程的错误一般不会影响到其它进程，缺点就是信息资源共享麻烦。而线程只是进程启动的执行单元，它是共享进程资源的，创建销毁、切换简单，速度很快，占用内存少，CPU利用率高。但是需要程序员管控的东西也比较多，相互影响出问题的机率较大，一个线程挂掉将导致整个进程挂掉，所以从程序员的角度来讲，我们只能看到某种代码是线程安全的，而没有说进程安全的。
```
#### 在进程和线程上，应该怎么选择
```
我们平时在写代码的时候一般使用线程会比较多，像需要频繁创建销毁的，要处理大量运算、数据，又要能很好的显示界面和及时响应消息的优先选择多线程，因为像这些运算会消耗大量的CPU，常见的有算法处理和图像处理。还有一些操作允许并发而且有可能阻塞的, 也推荐使用多线程. 例如SOCKET, 磁盘操作等等。进程一般来说更稳定，而且它是内存隔离的，单个进程的异常不会导致整个应用的崩溃，方便调试，像很多服务器默认是使用进程模式的。
```

#### 线程之间是如何通信的
```
一个是使用全局变量进行通信，还有就是可以使用自定义的消息机制传递信息。
其实因为各个线程之间它是共享进程的资源的，所以它没有像进程通信中的用于数据交换的通信方式，它通信的主要目的是用于线程同步，所以像一些互斥锁啊临界区啊CEvent事件对象和信号量对象都可以实现线程的通信和同步。
```

#### 进程之间是如何通信的
```
进程间的通信方式有PIPE管道，信号量，消息队列，共享内存，还可以通过 socket套接字进行通信。
根据信息量大小的不同可以分为低级通信和高级通信，在选择上，如果用户传递的信息较少．或是需要通过信号来触发某些行为的，一般用信号机制就能解决，
如果进程间要求传递的信息量比较大或者有交换数据的要求，那么就要使用共享内存和套接字这些通信方式。
```

名词解释：
管道其实是存在于内存中的一种特殊文件，它不属于文件系统，有自己的数据结构，根据使用范围还可分为无名管道和命名管道。
共享内存是通过将共享的内存缓冲区直接附加到进程的虚拟地址空间中来实现的，它是利用内存缓冲区直接交换信息，不需要复制，很快捷、信息量大。
消息队列缓冲是由系统调用函数来实现消息发送和接收之间的同步，它允许任意进程通过共享消息队列来实现进程间通信．但是信息的复制需要耗费大量CPU，
所以不适用于信息量大或操作频繁的场合。

#### 线程同步和线程异步
```
同步是指一个线程要等待另一个线程执行完之后才开始执行当前的线程。
异步是指一个线程去执行，它的下一个线程不必等待它执行完就开始执行。
一般一个进程启动的多个不相干线程，它们之间的相互关系就为异步，比如游戏有图像和背景音乐，图像是由玩家操作的 而背景音乐是系统循环播放，它们两个线程之间没什么关系各干各的，这就是线程异步。至于同步的话指的是多线程同时操作一个数据，这个时候需要对数据添加保护，这个保护就是线程的同步

同步使用场景：对于多个线程同时访问一块数据的时候，必须使用同步，否则可能会出现不安全的情况，有一种情况不需要同步技术，那就是原子操作，
也就是说操作系统在底层保证了操作要么全部做完，要么不做。

异步的使用场景：当只有一个线程访问当前数据的时候。比如观察者模式，它没有共享区，主题发生变化后通知观察者更新，主题继续做自己的事情，
不需要等待观察者更新完成后再工作。
```

#### 多线程同步和互斥有几种实现方法，分别适用什么情况
````
线程同步的话有临界区，互斥量，信号量，事件。
临界区适合一个进程内的多线程访问公共区域或代码段时使用。
互斥量是可以命名的，也就是说它可以适用不同进程内多线程访问公共资源时使用。
所以在选择上如果是在进程内部使用的话，用临界区会带来速度上的优势并且能够减少资源占用量。

信号量与临界区和互斥量不同，它是允许多个线程同时访问公共资源的，它相当于操作系统的PV操作，它会事先设定一个最大线程数，如果线程占用数达到最大，
那么其它线程就不能再进来，如果有部分线程释放资源了，那么其它线程才能进来访问资源。

事件是通过通知操作的方式来保持线程同步。
注意：互斥量，事件，信号量都是内核对象，可以跨进程使用。
````
```
    P（S）：①将信号量S的值减1，即S=S-1；
           ②如果S³0，则该进程继续执行；否则该进程置为等待状态，排入等待队列。
    V（S）：①将信号量S的值加1，即S=S+1；
           ②如果S>0，则该进程继续执行；否则释放队列中第一个等待信号量的进程。
```
#### C++多线程有几种实现方法
```
直接使用WIN32 API CreateThread，
或者用C运行库_beginthread创建线程,MFC的话用AfxBeginThread. 还有就是运用第三方线程库，比如boost的thread等等。

_beginthread和CreateThread的区别：_beginthread内部调用了CreateThread.
如果你的程序只调用 Win32 API/SDK ，就放心用 CreateThread，如果要用到C++运行时库，那么就要使用_beginthreadex，因为C++运行库有一些函数里面使用了全局变量，beginthreadex 为这些全局变量做了处理，使得每个线程都有一份独立的“全局”量，在这种情况下使用CreateThread的话就会出现不安全的问题

```
●进程有哪几种状态，状态转换图，及导致转换的事件


#### 死锁
```
概念：进程间进行通信或相互竞争系统资源而产生的永久阻塞，若无外力作用将永远处在死锁状态。

产生原因：（1）系统资源不足；（2）进程运行推进顺序与速度不同也可能导致死锁；（3）资源分配不当；

产生死锁四个必要条件：
（1） 互斥条件：就是一个资源每次只能被一个进程使用。
（2） 请求与保持条件：一个进程在请求其它资源而阻塞时，但是它对自己已获得的资源又保持不放。
（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。
（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

预防死锁和避免死锁的方法：
在系统设计、进程调度方面注意不让产生死锁的四个必要条件成立，确定资源的合理分配算法，避免进程永远占用系统资源，对资源分配要进行合理的规划。
```
#### 多线程中栈与堆是公有的还是私有的
因为线程是共享进程的资源的，所以栈是私有的，堆是公有的。

#### 线程池的概念
线程池就是一堆已经创建好的线程，最大数目一定，然后初始后都处于空闲状态，当有新任务进来时就从线程池中取出空闲线程处理任务，任务完成之后又重新放回去，当线程池中的所有线程都在任务时，只能等待有线程结束任务才能继续执行。

版权声明： https://blog.csdn.net/zhouchunyue/article/details/79271869 
