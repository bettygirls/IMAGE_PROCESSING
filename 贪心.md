

## 递归和贪心

贪心算法所作的贪心选择可以依赖于以往所作过的选择，但决不依赖于将来所作的选择，也不依赖于子问题的解。正是由于这种差别，动态规划算法通常以自底向上的方式解各子问题，而贪心算法则通常以自顶向下的方式进行,以迭代的方式作出相继的贪心选择，
每作一次贪心选择就将所求问题简化为一个规模更小的子问题。  

贪心的过程是一个选择最大值的过程，包含某个状态选择或者是不选择的问题，根据目标函数的最大值来判断，同时还要有自变量的约束，或者可以说是一个求解约束方程组的过程  

递归是一个递推式的模拟过程，根据递归关系式给出实现方法，可以从结尾开始分析，也可以从初始状态开始分析，一般过程为：
>> 递归终止条件  

>> 递归状态转移方程  

>> 回溯语句  （可以添加剪枝）

>> 回溯之后进行重新递归  

#### 如何区分一个问题用贪心还是动态规划
所有可以用贪心解决的问题都可以用动态规划，贪心是利用局部的最大化来逼近全局的最大化，但是一个优化问题如果存在局部极值的话
该方法往往是不可取的  


+ 凑钱的最少货币数
```

```
+ 摇摆序列问题
```
```
+ 跳跃游戏1
```
```
+ 跳跃游戏2
```
```
+ 加油站问题
```
```
+ 删除给定数字使得剩下的数最小
```
```
## 动态规划
动态规划问题的求解方法其实是固定的，首先列出初始状态， 然后根据初始状态得到其他状态，总结出状态转移方程，最多的优化就是路径的压缩
而对于子数组，子串等连续状态的求解可以用少数几个变量，子序列等依赖前面状态的状态转移则不可以

#### 0/1 背包问题
```
int value[N +1] = {0,6,3,5,4,6};
int weight[N=1] = {0,2,2,6,5,4}； //补0 为了方便回退
int f[N+1][V+1] = {0}; //f[0][0] 初始化为0

for(int i = 1; i <= N; i ++)
for(int j = 1; i <= V; j++){
     if(j < weight[i]){    //背包容量小于当前元素重量，无法添加当前元素
        f[i][j] = f[i -1][j];  
     }else{
         int x = f[i -1][j];    //状态方程   无法添加第i个元素，和原来价值一样
	 int y = f[i -1][j -weight[i]] +vaule[i];   //可以添加第i个元素,回退判断
	 f[i][j] = x < y ? y : x;
     }
}

```
#### 换钱最少货币数
     完全不使用当前货币的情况下的最少张数
     使用一张当前货币的最少张数
     使用2张当前货币的最少张数
     
```
//每个值代表一种面值的货币，每种面值的货币可以使用任意张，再给定一个整数aim代表要找的钱数
//求组成aim最少的货币数

int min1(int left, int up){
    return left > up ? up : left;
}
int minCoins(int arr[], const int aim){
    if(arr[0] == '\0' || aim < 0)
    	return -1;
    const int row = 3;
    const int col = aim;
    int dp[row][20 +1];
    // 第一列初始化
    for(int i = 0; i < row; i+=){
       dp[i][0] = 0;
    }
    // 第一行初始化
    for(int j =1; j <= col; j++){
       dp[0][j] = MAX;
       if((j -arr[0]) >= 0 && dp[0][j -arr[0]] != MAX)
          dp[0][j] = dp[0][j -arr[0]] +1;  //可以使用好多张
    }
    
    int left = 0;
    for(int i =1; i < row; i++)
    for(int j =1; j <= aim; j++){
       left = MAX;
       if((j - arr[i]) >= 0 && dp[i][j -arr[i]] != MAX) 
          left = dp[i][j -arr[i]] +1;
	dp[i][j] =min1(left, dp[i-1][j]);
    }
    return dp[row -1][aim];
}

```

#### 换钱最少货币数（2）
每个值仅代表一张钱的面值，给定一个整数aim代表要找的钱数，求组成aim的最少货币数
```
// arr = [5,2,5,3];
int min1(int left,int up){
    return left > up ? up : left;
}
int minCoins(int arr[], const int aim){
     if(arr[0] == '\0' || aim < 0)
    	return -1;
    const int row = 3;
    const int col = aim;
    int dp[row][7+1];
    //第一列初始化，表示钱数为0
    for(int i = 0; i < row; i++){
    	dp[i][0] = 0;
    }
    //第一行
    for(int j =1; j <= col; j++){
        dp[0][j] =MAX;
    }
    dp[0][arr[0]] =1; // 只有一张
    
    int left = 0;
    for(int i = 1; i < row; i++)
       for(int j = 1; j <= aim; j++){
           left = MAX;
	   if(j -arr[i] >= 0 && dp[i-1][j -arr[i]] != MAX){
	      left = dp[i-1][j - arr[i]] +1;
	   }
	   dp[i][j] = min1(left, dp[i-1][j]);
       }
       return dp[row -1][aim];   
}

```

####  最长递增子序列 O（N*logN）
```
vector<int> getmaxIncArr(vector<int> &arr){
	// 未初始化 或者 初始化后没有元素
    vector<int> res;
    if (arr.empty() || arr.size() == 0)
      return  res;

    res.push_back(arr[0]);
    int j;
    for (int i = 0; i < arr.size(); i++){
      j = 0; 
      if (res.back() < arr.at(i)){ //如果大于结果数组的最后一个元素直接放在末尾
        res.push_back(arr.at(i));
      }
      else
      { //找到数组中从左向右第一个大于当前元素的数组进行替换
        while (j <= res.size() - 1){   //此处可以用二分查找替换顺序查找 O(logN)，因为 res 是有序数组
          if (res.at(j) > arr.at(i)){
            res.at(j) = arr.at(i);
            break;
          }
          j++;
        }
      }

	}

	return res;

}
```
#### 最长公共子序列
#### 最长公共子串
#### 汉诺塔
#### 矩阵的最小路径和
#### 跳跃游戏
#### 数组中的最长连续序列
#### n皇后问题
