## 递归和贪心

贪心算法所作的贪心选择可以依赖于以往所作过的选择，但决不依赖于将来所作的选择，也不依赖于子问题的解。正是由于这种差别，动态规划算法通常以自底向上的方式解各子问题，而贪心算法则通常以自顶向下的方式进行,以迭代的方式作出相继的贪心选择，
每作一次贪心选择就将所求问题简化为一个规模更小的子问题。  

贪心的过程是一个选择最大值的过程，包含某个状态选择或者是不选择的问题，根据目标函数的最大值来判断，同时还要有自变量的约束，或者可以说是一个求解约束方程组的过程
而递归是一个递推式的模拟过程，根据递归关系式给出实现方法，可以从结尾开始分析，也可以从初始状态开始分析，一般过程为：
>> 递归终止条件  

>> 递归状态转移方程  

>> 回溯语句  

>> 回溯之后进行重新递归  


## 动态规划
动态规划问题的求解方法其实是固定的，首先列出初始状态， 然后根据初始状态得到其他状态，总结出状态转移方程，最多的优化就是路径的压缩
而对于子数组，子串等连续状态的求解可以用少数几个变量，子序列等依赖前面状态的状态转移则不可以

####  最长递增子序列 O（N*logN）
```
vector<int> getmaxIncArr(vector<int> &arr){
	// 未初始化 或者 初始化后没有元素
    vector<int> res;
    if (arr.empty() || arr.size() == 0)
      return  res;

    res.push_back(arr[0]);
    int j;
    for (int i = 0; i < arr.size(); i++){
      j = 0; 
      if (res.back() < arr.at(i)){ //如果大于结果数组的最后一个元素直接放在末尾
        res.push_back(arr.at(i));
      }
      else
      { //找到数组中从左向右第一个大于当前元素的数组进行替换
        while (j <= res.size() - 1){   //此处可以用二分查找替换顺序查找 O(logN)，因为 res 是有序数组
          if (res.at(j) > arr.at(i)){
            res.at(j) = arr.at(i);
            break;
          }
          j++;
        }
      }

	}

	return res;

}
```
