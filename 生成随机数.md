```
#include<iostream>
#include<stdlib.h>
#include<time.h>

int rand1to5(){
  int num;
  srand(time(0));
  num = rand() % 5 + 1; 
  //cout<<rand()%MAX<<endl;//MAX为最大值，其随机域为0~MAX-1
  return num;
}

int rand1to7(){
 int num;
 do{
    num = ((rand1to5() - 1) *5 + rand1to5() -1) % 7;
   }while(num > 20);
   return num ;
}

```

解释：
```
rand() -1 => 0, 1, 2, 3, 4
5 * (rand() -1) => 0, 5, 10, 15, 20
5 * (rand() -1) + rand() -1 => 0,1,2,3,4......24  两次调用随机生成方法，进行插空

必须保证一级生成的随机数可以正好对二级生成的随机数进行插空


```

给定不均等概率生成均等概率的数
```
int rand01p(){
	double p = 0.83;
	return rand() % 100 / (double)101 < p ? 0 : 1;
}
int rand01(){
	int num;
	do{
		num = rand01p();
	} while (num == rand01p()); //这里是新调用了一次 rand01() 如果两次结果相同（比如00 和11），就会重新生成
	return num == 1 ? 1 : 0;
}
```

以p概率产生0， 以1-p概率产生1， 编写程序使得产生1~6的随机数 

```
以0.83的概率产生0，以0.17的概率产生1
保证了产生 0 和 1 的概率是相等的

产生 01 的概率 p*(1-p)
产生 10 的概率 (1-p)*p
其他情况重做

不均等概率 -> 均等概率 -> 指定范围的均等概率

```

给定 1 ~ m 的随机生成器， 得到 1~n 的随机生成器
```
1 ~ 5 -> 0 ~ 4  
      -> 0 ~ 3  只筛选， 4 重做
      
0 ~ 4 -> 0 ~ 3
0 ~ 4 是 5进制， 
0 ~ 24 是 2 个 5 进制  0 ~ 5^k -1 

1 ~ m -> 1 ~ n
m进制
0 ~ m-1  0 ~ n-1
 0 ~ n-1 的区间需要几个m进制的位才够， 然后进行筛选
 
```
